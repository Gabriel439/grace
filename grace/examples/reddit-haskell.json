{
  "kind": "Listing",
  "data": {
    "after": "t3_ojk63k",
    "dist": 26,
    "modhash": "",
    "geo_filter": null,
    "children": [
      {
        "kind": "t3",
        "data": {
          "approved_at_utc": null,
          "subreddit": "haskell",
          "selftext": "This is your opportunity to ask any questions you feel don't deserve their own threads, no matter how small or simple they might be!",
          "author_fullname": "t2_4hurx",
          "saved": false,
          "mod_reason_title": null,
          "gilded": 0,
          "clicked": false,
          "title": "Monthly Hask Anything (July 2021)",
          "link_flair_richtext": [],
          "subreddit_name_prefixed": "r/haskell",
          "collections": [
            {
              "permalink": "https://www.reddit.com/r/haskell/collection/f998970b-a622-480a-aed4-f8d9ad64ee7b",
              "link_ids": [
                "t3_laur0s",
                "t3_m0f2y9",
                "t3_mj7kv5",
                "t3_n2s8yk",
                "t3_nqjp2c",
                "t3_ocz5s5"
              ],
              "description": "",
              "title": "Hask Anything",
              "created_at_utc": 1612270088.064,
              "subreddit_id": "t5_2qh36",
              "author_name": "taylorfausak",
              "collection_id": "f998970b-a622-480a-aed4-f8d9ad64ee7b",
              "author_id": "t2_4hurx",
              "last_update_utc": 1625322715.36,
              "display_layout": null
            }
          ],
          "hidden": false,
          "pwls": 6,
          "link_flair_css_class": "",
          "downs": 0,
          "top_awarded_type": null,
          "hide_score": false,
          "name": "t3_ocz5s5",
          "quarantine": false,
          "link_flair_text_color": "light",
          "upvote_ratio": 1,
          "author_flair_background_color": null,
          "subreddit_type": "public",
          "ups": 31,
          "total_awards_received": 0,
          "media_embed": {},
          "author_flair_template_id": null,
          "is_original_content": false,
          "user_reports": [],
          "secure_media": null,
          "is_reddit_media_domain": false,
          "is_meta": false,
          "category": null,
          "secure_media_embed": {},
          "link_flair_text": "question",
          "can_mod_post": false,
          "score": 31,
          "approved_by": null,
          "is_created_from_ads_ui": false,
          "author_premium": false,
          "thumbnail": "",
          "edited": false,
          "author_flair_css_class": null,
          "author_flair_richtext": [],
          "gildings": {},
          "content_categories": null,
          "is_self": true,
          "mod_note": null,
          "created": 1625351515,
          "link_flair_type": "text",
          "wls": 6,
          "removed_by_category": null,
          "banned_by": null,
          "author_flair_type": "text",
          "domain": "self.haskell",
          "allow_live_comments": false,
          "selftext_html": "&lt;!-- SC_OFF --&gt;&lt;div class=\"md\"&gt;&lt;p&gt;This is your opportunity to ask any questions you feel don&amp;#39;t deserve their own threads, no matter how small or simple they might be!&lt;/p&gt;\n&lt;/div&gt;&lt;!-- SC_ON --&gt;",
          "likes": null,
          "suggested_sort": "new",
          "banned_at_utc": null,
          "view_count": null,
          "archived": false,
          "no_follow": false,
          "is_crosspostable": false,
          "pinned": false,
          "over_18": false,
          "all_awardings": [],
          "awarders": [],
          "media_only": false,
          "link_flair_template_id": "cceadda8-25af-11eb-ba66-0e76c7963e23",
          "can_gild": false,
          "spoiler": false,
          "locked": false,
          "author_flair_text": null,
          "treatment_tags": [],
          "visited": false,
          "removed_by": null,
          "num_reports": null,
          "distinguished": null,
          "subreddit_id": "t5_2qh36",
          "mod_reason_by": null,
          "removal_reason": null,
          "link_flair_background_color": "#646d73",
          "id": "ocz5s5",
          "is_robot_indexable": true,
          "report_reasons": null,
          "author": "taylorfausak",
          "discussion_type": null,
          "num_comments": 83,
          "send_replies": false,
          "whitelist_status": "all_ads",
          "contest_mode": false,
          "mod_reports": [],
          "author_patreon_flair": false,
          "author_flair_text_color": null,
          "permalink": "/r/haskell/comments/ocz5s5/monthly_hask_anything_july_2021/",
          "parent_whitelist_status": "all_ads",
          "stickied": true,
          "url": "https://www.reddit.com/r/haskell/comments/ocz5s5/monthly_hask_anything_july_2021/",
          "subreddit_subscribers": 64950,
          "created_utc": 1625322715,
          "num_crossposts": 0,
          "media": null,
          "is_video": false
        }
      },
      {
        "kind": "t3",
        "data": {
          "approved_at_utc": null,
          "subreddit": "haskell",
          "selftext": "",
          "author_fullname": "t2_fjd8s",
          "saved": false,
          "mod_reason_title": null,
          "gilded": 0,
          "clicked": false,
          "title": "Displaying Real-Time Data in Your Web Application Without Hassle: IHP Auto Refresh âœ¨",
          "link_flair_richtext": [],
          "subreddit_name_prefixed": "r/haskell",
          "hidden": false,
          "pwls": 6,
          "link_flair_css_class": null,
          "downs": 0,
          "top_awarded_type": null,
          "hide_score": false,
          "name": "t3_om0bwp",
          "quarantine": false,
          "link_flair_text_color": "dark",
          "upvote_ratio": 0.97,
          "author_flair_background_color": null,
          "subreddit_type": "public",
          "ups": 21,
          "total_awards_received": 0,
          "media_embed": {},
          "author_flair_template_id": null,
          "is_original_content": false,
          "user_reports": [],
          "secure_media": null,
          "is_reddit_media_domain": false,
          "is_meta": false,
          "category": null,
          "secure_media_embed": {},
          "link_flair_text": null,
          "can_mod_post": false,
          "score": 21,
          "approved_by": null,
          "is_created_from_ads_ui": false,
          "author_premium": false,
          "thumbnail": "",
          "edited": false,
          "author_flair_css_class": null,
          "author_flair_richtext": [],
          "gildings": {},
          "content_categories": null,
          "is_self": false,
          "mod_note": null,
          "created": 1626538995,
          "link_flair_type": "text",
          "wls": 6,
          "removed_by_category": null,
          "banned_by": null,
          "author_flair_type": "text",
          "domain": "ihp.digitallyinduced.com",
          "allow_live_comments": false,
          "selftext_html": null,
          "likes": null,
          "suggested_sort": null,
          "banned_at_utc": null,
          "url_overridden_by_dest": "https://ihp.digitallyinduced.com/ShowPost?postId=a2d56dc7-d2ba-46a0-a8e7-345741dcbb6b",
          "view_count": null,
          "archived": false,
          "no_follow": false,
          "is_crosspostable": false,
          "pinned": false,
          "over_18": false,
          "all_awardings": [],
          "awarders": [],
          "media_only": false,
          "can_gild": false,
          "spoiler": false,
          "locked": false,
          "author_flair_text": null,
          "treatment_tags": [],
          "visited": false,
          "removed_by": null,
          "num_reports": null,
          "distinguished": null,
          "subreddit_id": "t5_2qh36",
          "mod_reason_by": null,
          "removal_reason": null,
          "link_flair_background_color": "",
          "id": "om0bwp",
          "is_robot_indexable": true,
          "report_reasons": null,
          "author": "_query",
          "discussion_type": null,
          "num_comments": 1,
          "send_replies": true,
          "whitelist_status": "all_ads",
          "contest_mode": false,
          "mod_reports": [],
          "author_patreon_flair": false,
          "author_flair_text_color": null,
          "permalink": "/r/haskell/comments/om0bwp/displaying_realtime_data_in_your_web_application/",
          "parent_whitelist_status": "all_ads",
          "stickied": false,
          "url": "https://ihp.digitallyinduced.com/ShowPost?postId=a2d56dc7-d2ba-46a0-a8e7-345741dcbb6b",
          "subreddit_subscribers": 64950,
          "created_utc": 1626510195,
          "num_crossposts": 0,
          "media": null,
          "is_video": false
        }
      },
      {
        "kind": "t3",
        "data": {
          "approved_at_utc": null,
          "subreddit": "haskell",
          "selftext": "",
          "author_fullname": "t2_4y723",
          "saved": false,
          "mod_reason_title": null,
          "gilded": 0,
          "clicked": false,
          "title": "Hspec Hooks",
          "link_flair_richtext": [],
          "subreddit_name_prefixed": "r/haskell",
          "hidden": false,
          "pwls": 6,
          "link_flair_css_class": null,
          "downs": 0,
          "top_awarded_type": null,
          "hide_score": false,
          "name": "t3_olt2yn",
          "quarantine": false,
          "link_flair_text_color": "dark",
          "upvote_ratio": 1,
          "author_flair_background_color": null,
          "subreddit_type": "public",
          "ups": 34,
          "total_awards_received": 0,
          "media_embed": {},
          "author_flair_template_id": null,
          "is_original_content": false,
          "user_reports": [],
          "secure_media": null,
          "is_reddit_media_domain": false,
          "is_meta": false,
          "category": null,
          "secure_media_embed": {},
          "link_flair_text": null,
          "can_mod_post": false,
          "score": 34,
          "approved_by": null,
          "is_created_from_ads_ui": false,
          "author_premium": false,
          "thumbnail": "",
          "edited": false,
          "author_flair_css_class": null,
          "author_flair_richtext": [],
          "gildings": {},
          "content_categories": null,
          "is_self": false,
          "mod_note": null,
          "created": 1626508177,
          "link_flair_type": "text",
          "wls": 6,
          "removed_by_category": null,
          "banned_by": null,
          "author_flair_type": "text",
          "domain": "parsonsmatt.org",
          "allow_live_comments": false,
          "selftext_html": null,
          "likes": null,
          "suggested_sort": null,
          "banned_at_utc": null,
          "url_overridden_by_dest": "https://www.parsonsmatt.org/2021/07/16/hspec_hooks.html",
          "view_count": null,
          "archived": false,
          "no_follow": false,
          "is_crosspostable": false,
          "pinned": false,
          "over_18": false,
          "all_awardings": [],
          "awarders": [],
          "media_only": false,
          "can_gild": false,
          "spoiler": false,
          "locked": false,
          "author_flair_text": null,
          "treatment_tags": [],
          "visited": false,
          "removed_by": null,
          "num_reports": null,
          "distinguished": null,
          "subreddit_id": "t5_2qh36",
          "mod_reason_by": null,
          "removal_reason": null,
          "link_flair_background_color": "",
          "id": "olt2yn",
          "is_robot_indexable": true,
          "report_reasons": null,
          "author": "ephrion",
          "discussion_type": null,
          "num_comments": 2,
          "send_replies": true,
          "whitelist_status": "all_ads",
          "contest_mode": false,
          "mod_reports": [],
          "author_patreon_flair": false,
          "author_flair_text_color": null,
          "permalink": "/r/haskell/comments/olt2yn/hspec_hooks/",
          "parent_whitelist_status": "all_ads",
          "stickied": false,
          "url": "https://www.parsonsmatt.org/2021/07/16/hspec_hooks.html",
          "subreddit_subscribers": 64950,
          "created_utc": 1626479377,
          "num_crossposts": 0,
          "media": null,
          "is_video": false
        }
      },
      {
        "kind": "t3",
        "data": {
          "approved_at_utc": null,
          "subreddit": "haskell",
          "selftext": "When defining a custom record type to match some table, I sometimes want to use record field types other than the default ones assumed by opaleye.\n\nE.g. for a (Field SqlNumeric), I don't want to use a Scientific in the Haskell record type when the scale of the postgresql NUMERIC field is 0; it makes more sense to use Integer instead of Scientific. Similarly, if a column is of a domain that constrains the value to be non-negative, it may make more sense to use an unsigned type such as Word64 instead of Int64.\n\nConsider the following code:\n```\ndata Rec' a b = Rec { a :: a, b :: b }\ntype Rec1 = Rec' Scientific Scientific\ntype Rec2 = Rec' Integer Integer\ntype RecField = Rec' (Field SqlNumeric) (Field SqlNumeric)\n$(makeAdaptorAndInstance \"pRec\" ''Rec')\nrecTable :: Table RecField RecField\nrecTable = table \"rec\" (pRec Rec { a = tableField \"a\", b = tableField \"b\" })\n```\n\nIf I try to use `selectTable recTable` and `runSelect` to read a `[Rec1]` it's fine, but if I try to read a `[Rec2]`, I get a compilation error (No instance for (Opaleye.Internal.RunQuery.DefaultFromField SqlNumeric Integer). How can I simply map the table to a record type that uses `Integer` instead of `Scientific` without adding much boilerplate? I only need to read the tables, not write to them.",
          "author_fullname": "t2_5qs9j",
          "saved": false,
          "mod_reason_title": null,
          "gilded": 0,
          "clicked": false,
          "title": "How to simply do opaleye field type conversion",
          "link_flair_richtext": [],
          "subreddit_name_prefixed": "r/haskell",
          "hidden": false,
          "pwls": 6,
          "link_flair_css_class": null,
          "downs": 0,
          "top_awarded_type": null,
          "hide_score": false,
          "name": "t3_om8m6d",
          "quarantine": false,
          "link_flair_text_color": "dark",
          "upvote_ratio": 1,
          "author_flair_background_color": null,
          "subreddit_type": "public",
          "ups": 1,
          "total_awards_received": 0,
          "media_embed": {},
          "author_flair_template_id": null,
          "is_original_content": false,
          "user_reports": [],
          "secure_media": null,
          "is_reddit_media_domain": false,
          "is_meta": false,
          "category": null,
          "secure_media_embed": {},
          "link_flair_text": null,
          "can_mod_post": false,
          "score": 1,
          "approved_by": null,
          "is_created_from_ads_ui": false,
          "author_premium": false,
          "thumbnail": "",
          "edited": false,
          "author_flair_css_class": null,
          "author_flair_richtext": [],
          "gildings": {},
          "content_categories": null,
          "is_self": true,
          "mod_note": null,
          "created": 1626571544,
          "link_flair_type": "text",
          "wls": 6,
          "removed_by_category": null,
          "banned_by": null,
          "author_flair_type": "text",
          "domain": "self.haskell",
          "allow_live_comments": false,
          "selftext_html": "&lt;!-- SC_OFF --&gt;&lt;div class=\"md\"&gt;&lt;p&gt;When defining a custom record type to match some table, I sometimes want to use record field types other than the default ones assumed by opaleye.&lt;/p&gt;\n\n&lt;p&gt;E.g. for a (Field SqlNumeric), I don&amp;#39;t want to use a Scientific in the Haskell record type when the scale of the postgresql NUMERIC field is 0; it makes more sense to use Integer instead of Scientific. Similarly, if a column is of a domain that constrains the value to be non-negative, it may make more sense to use an unsigned type such as Word64 instead of Int64.&lt;/p&gt;\n\n&lt;p&gt;Consider the following code:\n&lt;code&gt;\ndata Rec&amp;#39; a b = Rec { a :: a, b :: b }\ntype Rec1 = Rec&amp;#39; Scientific Scientific\ntype Rec2 = Rec&amp;#39; Integer Integer\ntype RecField = Rec&amp;#39; (Field SqlNumeric) (Field SqlNumeric)\n$(makeAdaptorAndInstance &amp;quot;pRec&amp;quot; &amp;#39;&amp;#39;Rec&amp;#39;)\nrecTable :: Table RecField RecField\nrecTable = table &amp;quot;rec&amp;quot; (pRec Rec { a = tableField &amp;quot;a&amp;quot;, b = tableField &amp;quot;b&amp;quot; })\n&lt;/code&gt;&lt;/p&gt;\n\n&lt;p&gt;If I try to use &lt;code&gt;selectTable recTable&lt;/code&gt; and &lt;code&gt;runSelect&lt;/code&gt; to read a &lt;code&gt;[Rec1]&lt;/code&gt; it&amp;#39;s fine, but if I try to read a &lt;code&gt;[Rec2]&lt;/code&gt;, I get a compilation error (No instance for (Opaleye.Internal.RunQuery.DefaultFromField SqlNumeric Integer). How can I simply map the table to a record type that uses &lt;code&gt;Integer&lt;/code&gt; instead of &lt;code&gt;Scientific&lt;/code&gt; without adding much boilerplate? I only need to read the tables, not write to them.&lt;/p&gt;\n&lt;/div&gt;&lt;!-- SC_ON --&gt;",
          "likes": null,
          "suggested_sort": null,
          "banned_at_utc": null,
          "view_count": null,
          "archived": false,
          "no_follow": true,
          "is_crosspostable": false,
          "pinned": false,
          "over_18": false,
          "all_awardings": [],
          "awarders": [],
          "media_only": false,
          "can_gild": false,
          "spoiler": false,
          "locked": false,
          "author_flair_text": null,
          "treatment_tags": [],
          "visited": false,
          "removed_by": null,
          "num_reports": null,
          "distinguished": null,
          "subreddit_id": "t5_2qh36",
          "mod_reason_by": null,
          "removal_reason": null,
          "link_flair_background_color": "",
          "id": "om8m6d",
          "is_robot_indexable": true,
          "report_reasons": null,
          "author": "Syncopat3d",
          "discussion_type": null,
          "num_comments": 1,
          "send_replies": true,
          "whitelist_status": "all_ads",
          "contest_mode": false,
          "mod_reports": [],
          "author_patreon_flair": false,
          "author_flair_text_color": null,
          "permalink": "/r/haskell/comments/om8m6d/how_to_simply_do_opaleye_field_type_conversion/",
          "parent_whitelist_status": "all_ads",
          "stickied": false,
          "url": "https://www.reddit.com/r/haskell/comments/om8m6d/how_to_simply_do_opaleye_field_type_conversion/",
          "subreddit_subscribers": 64950,
          "created_utc": 1626542744,
          "num_crossposts": 0,
          "media": null,
          "is_video": false
        }
      },
      {
        "kind": "t3",
        "data": {
          "approved_at_utc": null,
          "subreddit": "haskell",
          "selftext": "",
          "author_fullname": "t2_qou7f",
          "saved": false,
          "mod_reason_title": null,
          "gilded": 0,
          "clicked": false,
          "title": "Size hints for streams in text package",
          "link_flair_richtext": [],
          "subreddit_name_prefixed": "r/haskell",
          "hidden": false,
          "pwls": 6,
          "link_flair_css_class": "",
          "downs": 0,
          "top_awarded_type": null,
          "hide_score": false,
          "name": "t3_om3a77",
          "quarantine": false,
          "link_flair_text_color": "light",
          "upvote_ratio": 1,
          "author_flair_background_color": null,
          "subreddit_type": "public",
          "ups": 2,
          "total_awards_received": 0,
          "media_embed": {},
          "author_flair_template_id": null,
          "is_original_content": false,
          "user_reports": [],
          "secure_media": null,
          "is_reddit_media_domain": false,
          "is_meta": false,
          "category": null,
          "secure_media_embed": {},
          "link_flair_text": "RFC",
          "can_mod_post": false,
          "score": 2,
          "approved_by": null,
          "is_created_from_ads_ui": false,
          "author_premium": false,
          "thumbnail": "",
          "edited": false,
          "author_flair_css_class": null,
          "author_flair_richtext": [],
          "gildings": {},
          "content_categories": null,
          "is_self": false,
          "mod_note": null,
          "created": 1626553603,
          "link_flair_type": "text",
          "wls": 6,
          "removed_by_category": null,
          "banned_by": null,
          "author_flair_type": "text",
          "domain": "github.com",
          "allow_live_comments": false,
          "selftext_html": null,
          "likes": null,
          "suggested_sort": null,
          "banned_at_utc": null,
          "url_overridden_by_dest": "https://github.com/haskell/text/issues/356",
          "view_count": null,
          "archived": false,
          "no_follow": false,
          "is_crosspostable": false,
          "pinned": false,
          "over_18": false,
          "all_awardings": [],
          "awarders": [],
          "media_only": false,
          "link_flair_template_id": "a01b58a0-6553-11eb-b2eb-0eb19e8d97a5",
          "can_gild": false,
          "spoiler": false,
          "locked": false,
          "author_flair_text": null,
          "treatment_tags": [],
          "visited": false,
          "removed_by": null,
          "num_reports": null,
          "distinguished": null,
          "subreddit_id": "t5_2qh36",
          "mod_reason_by": null,
          "removal_reason": null,
          "link_flair_background_color": "#646d73",
          "id": "om3a77",
          "is_robot_indexable": true,
          "report_reasons": null,
          "author": "Bodigrim",
          "discussion_type": null,
          "num_comments": 0,
          "send_replies": true,
          "whitelist_status": "all_ads",
          "contest_mode": false,
          "mod_reports": [],
          "author_patreon_flair": false,
          "author_flair_text_color": null,
          "permalink": "/r/haskell/comments/om3a77/size_hints_for_streams_in_text_package/",
          "parent_whitelist_status": "all_ads",
          "stickied": false,
          "url": "https://github.com/haskell/text/issues/356",
          "subreddit_subscribers": 64950,
          "created_utc": 1626524803,
          "num_crossposts": 0,
          "media": null,
          "is_video": false
        }
      },
      {
        "kind": "t3",
        "data": {
          "approved_at_utc": null,
          "subreddit": "haskell",
          "selftext": "",
          "author_fullname": "t2_fpj4y",
          "saved": false,
          "mod_reason_title": null,
          "gilded": 0,
          "clicked": false,
          "title": "The Haskell Interlude podcast teaser episode",
          "link_flair_richtext": [],
          "subreddit_name_prefixed": "r/haskell",
          "hidden": false,
          "pwls": 6,
          "link_flair_css_class": null,
          "downs": 0,
          "top_awarded_type": null,
          "hide_score": false,
          "name": "t3_olpi4t",
          "quarantine": false,
          "link_flair_text_color": "dark",
          "upvote_ratio": 0.92,
          "author_flair_background_color": null,
          "subreddit_type": "public",
          "ups": 10,
          "total_awards_received": 0,
          "media_embed": {},
          "author_flair_template_id": null,
          "is_original_content": false,
          "user_reports": [],
          "secure_media": null,
          "is_reddit_media_domain": false,
          "is_meta": false,
          "category": null,
          "secure_media_embed": {},
          "link_flair_text": null,
          "can_mod_post": false,
          "score": 10,
          "approved_by": null,
          "is_created_from_ads_ui": false,
          "author_premium": false,
          "thumbnail": "",
          "edited": false,
          "author_flair_css_class": null,
          "author_flair_richtext": [],
          "gildings": {},
          "content_categories": null,
          "is_self": false,
          "mod_note": null,
          "created": 1626496631,
          "link_flair_type": "text",
          "wls": 6,
          "removed_by_category": null,
          "banned_by": null,
          "author_flair_type": "text",
          "domain": "haskell.foundation",
          "allow_live_comments": false,
          "selftext_html": null,
          "likes": null,
          "suggested_sort": null,
          "banned_at_utc": null,
          "url_overridden_by_dest": "https://haskell.foundation/podcast/",
          "view_count": null,
          "archived": false,
          "no_follow": false,
          "is_crosspostable": false,
          "pinned": false,
          "over_18": false,
          "all_awardings": [],
          "awarders": [],
          "media_only": false,
          "can_gild": false,
          "spoiler": false,
          "locked": false,
          "author_flair_text": null,
          "treatment_tags": [],
          "visited": false,
          "removed_by": null,
          "num_reports": null,
          "distinguished": null,
          "subreddit_id": "t5_2qh36",
          "mod_reason_by": null,
          "removal_reason": null,
          "link_flair_background_color": "",
          "id": "olpi4t",
          "is_robot_indexable": true,
          "report_reasons": null,
          "author": "myShoggoth",
          "discussion_type": null,
          "num_comments": 3,
          "send_replies": true,
          "whitelist_status": "all_ads",
          "contest_mode": false,
          "mod_reports": [],
          "author_patreon_flair": false,
          "author_flair_text_color": null,
          "permalink": "/r/haskell/comments/olpi4t/the_haskell_interlude_podcast_teaser_episode/",
          "parent_whitelist_status": "all_ads",
          "stickied": false,
          "url": "https://haskell.foundation/podcast/",
          "subreddit_subscribers": 64950,
          "created_utc": 1626467831,
          "num_crossposts": 0,
          "media": null,
          "is_video": false
        }
      },
      {
        "kind": "t3",
        "data": {
          "approved_at_utc": null,
          "subreddit": "haskell",
          "selftext": "Hi all,\n\nJust wanted to share my final year university project repo which was implementing a language very similar to Elm:\n\n[https://github.com/georgegarrington/Syphon](https://github.com/georgegarrington/Syphon)\n\nMegaparsec used for parser, Hindley-Milner system (albeit I never implemented let polymorphism) based on [this](https://www.cs.cornell.edu/courses/cs3110/2021sp/textbook/interp/inference.html) Cornell course used for the type system and custom transpiler made without using a string template library, didn't know this was a thing until after the deadline haha oops. Transpiles to ES6 making use of arrow functions for currying and uses React and Electron, useReducer hook in React is essentially the Elm architecture so this was used, and useEffect hook was used to implement subscriptions.\n\nWould love to know anyone's feedback at an amateur attempt at language implementation, and also hope this might help people working on a similar project :)",
          "author_fullname": "t2_6as3dmzn",
          "saved": false,
          "mod_reason_title": null,
          "gilded": 0,
          "clicked": false,
          "title": "Final year University project domain-specific language for GUI applications",
          "link_flair_richtext": [],
          "subreddit_name_prefixed": "r/haskell",
          "hidden": false,
          "pwls": 6,
          "link_flair_css_class": null,
          "downs": 0,
          "top_awarded_type": null,
          "hide_score": false,
          "name": "t3_olh2cm",
          "quarantine": false,
          "link_flair_text_color": "dark",
          "upvote_ratio": 0.97,
          "author_flair_background_color": null,
          "subreddit_type": "public",
          "ups": 38,
          "total_awards_received": 0,
          "media_embed": {},
          "author_flair_template_id": null,
          "is_original_content": false,
          "user_reports": [],
          "secure_media": null,
          "is_reddit_media_domain": false,
          "is_meta": false,
          "category": null,
          "secure_media_embed": {},
          "link_flair_text": null,
          "can_mod_post": false,
          "score": 38,
          "approved_by": null,
          "is_created_from_ads_ui": false,
          "author_premium": false,
          "thumbnail": "",
          "edited": false,
          "author_flair_css_class": null,
          "author_flair_richtext": [],
          "gildings": {},
          "content_categories": null,
          "is_self": true,
          "mod_note": null,
          "created": 1626471625,
          "link_flair_type": "text",
          "wls": 6,
          "removed_by_category": null,
          "banned_by": null,
          "author_flair_type": "text",
          "domain": "self.haskell",
          "allow_live_comments": false,
          "selftext_html": "&lt;!-- SC_OFF --&gt;&lt;div class=\"md\"&gt;&lt;p&gt;Hi all,&lt;/p&gt;\n\n&lt;p&gt;Just wanted to share my final year university project repo which was implementing a language very similar to Elm:&lt;/p&gt;\n\n&lt;p&gt;&lt;a href=\"https://github.com/georgegarrington/Syphon\"&gt;https://github.com/georgegarrington/Syphon&lt;/a&gt;&lt;/p&gt;\n\n&lt;p&gt;Megaparsec used for parser, Hindley-Milner system (albeit I never implemented let polymorphism) based on &lt;a href=\"https://www.cs.cornell.edu/courses/cs3110/2021sp/textbook/interp/inference.html\"&gt;this&lt;/a&gt; Cornell course used for the type system and custom transpiler made without using a string template library, didn&amp;#39;t know this was a thing until after the deadline haha oops. Transpiles to ES6 making use of arrow functions for currying and uses React and Electron, useReducer hook in React is essentially the Elm architecture so this was used, and useEffect hook was used to implement subscriptions.&lt;/p&gt;\n\n&lt;p&gt;Would love to know anyone&amp;#39;s feedback at an amateur attempt at language implementation, and also hope this might help people working on a similar project :)&lt;/p&gt;\n&lt;/div&gt;&lt;!-- SC_ON --&gt;",
          "likes": null,
          "suggested_sort": null,
          "banned_at_utc": null,
          "view_count": null,
          "archived": false,
          "no_follow": false,
          "is_crosspostable": false,
          "pinned": false,
          "over_18": false,
          "all_awardings": [],
          "awarders": [],
          "media_only": false,
          "can_gild": false,
          "spoiler": false,
          "locked": false,
          "author_flair_text": null,
          "treatment_tags": [],
          "visited": false,
          "removed_by": null,
          "num_reports": null,
          "distinguished": null,
          "subreddit_id": "t5_2qh36",
          "mod_reason_by": null,
          "removal_reason": null,
          "link_flair_background_color": "",
          "id": "olh2cm",
          "is_robot_indexable": true,
          "report_reasons": null,
          "author": "Snoo-35440",
          "discussion_type": null,
          "num_comments": 2,
          "send_replies": true,
          "whitelist_status": "all_ads",
          "contest_mode": false,
          "mod_reports": [],
          "author_patreon_flair": false,
          "author_flair_text_color": null,
          "permalink": "/r/haskell/comments/olh2cm/final_year_university_project_domainspecific/",
          "parent_whitelist_status": "all_ads",
          "stickied": false,
          "url": "https://www.reddit.com/r/haskell/comments/olh2cm/final_year_university_project_domainspecific/",
          "subreddit_subscribers": 64950,
          "created_utc": 1626442825,
          "num_crossposts": 0,
          "media": null,
          "is_video": false
        }
      },
      {
        "kind": "t3",
        "data": {
          "approved_at_utc": null,
          "subreddit": "haskell",
          "selftext": "As far as I know the `Base` type family is used to be able to work with normal recursive types like the standard list type instead of `data ListF a b = Cons a b | Nil`.\n\nI guess there are alternative approaches, but I lack the appropriate terms to reasearch further. Every tip is appreciated.\n\nThe question arose, because I translate Kmett's recursion schemes to my own typed language that unfortunately doesn't support type families.",
          "author_fullname": "t2_2ejjh9qv",
          "saved": false,
          "mod_reason_title": null,
          "gilded": 0,
          "clicked": false,
          "title": "What are the alternatives for the `Base` type families in recursion schemes?",
          "link_flair_richtext": [],
          "subreddit_name_prefixed": "r/haskell",
          "hidden": false,
          "pwls": 6,
          "link_flair_css_class": "",
          "downs": 0,
          "top_awarded_type": null,
          "hide_score": false,
          "name": "t3_olqe1y",
          "quarantine": false,
          "link_flair_text_color": "light",
          "upvote_ratio": 1,
          "author_flair_background_color": null,
          "subreddit_type": "public",
          "ups": 8,
          "total_awards_received": 0,
          "media_embed": {},
          "author_flair_template_id": null,
          "is_original_content": false,
          "user_reports": [],
          "secure_media": null,
          "is_reddit_media_domain": false,
          "is_meta": false,
          "category": null,
          "secure_media_embed": {},
          "link_flair_text": "question",
          "can_mod_post": false,
          "score": 8,
          "approved_by": null,
          "is_created_from_ads_ui": false,
          "author_premium": false,
          "thumbnail": "",
          "edited": false,
          "author_flair_css_class": null,
          "author_flair_richtext": [],
          "gildings": {},
          "content_categories": null,
          "is_self": true,
          "mod_note": null,
          "created": 1626499470,
          "link_flair_type": "text",
          "wls": 6,
          "removed_by_category": null,
          "banned_by": null,
          "author_flair_type": "text",
          "domain": "self.haskell",
          "allow_live_comments": false,
          "selftext_html": "&lt;!-- SC_OFF --&gt;&lt;div class=\"md\"&gt;&lt;p&gt;As far as I know the &lt;code&gt;Base&lt;/code&gt; type family is used to be able to work with normal recursive types like the standard list type instead of &lt;code&gt;data ListF a b = Cons a b | Nil&lt;/code&gt;.&lt;/p&gt;\n\n&lt;p&gt;I guess there are alternative approaches, but I lack the appropriate terms to reasearch further. Every tip is appreciated.&lt;/p&gt;\n\n&lt;p&gt;The question arose, because I translate Kmett&amp;#39;s recursion schemes to my own typed language that unfortunately doesn&amp;#39;t support type families.&lt;/p&gt;\n&lt;/div&gt;&lt;!-- SC_ON --&gt;",
          "likes": null,
          "suggested_sort": null,
          "banned_at_utc": null,
          "view_count": null,
          "archived": false,
          "no_follow": false,
          "is_crosspostable": false,
          "pinned": false,
          "over_18": false,
          "all_awardings": [],
          "awarders": [],
          "media_only": false,
          "link_flair_template_id": "cceadda8-25af-11eb-ba66-0e76c7963e23",
          "can_gild": false,
          "spoiler": false,
          "locked": false,
          "author_flair_text": null,
          "treatment_tags": [],
          "visited": false,
          "removed_by": null,
          "num_reports": null,
          "distinguished": null,
          "subreddit_id": "t5_2qh36",
          "mod_reason_by": null,
          "removal_reason": null,
          "link_flair_background_color": "#646d73",
          "id": "olqe1y",
          "is_robot_indexable": true,
          "report_reasons": null,
          "author": "reifyK",
          "discussion_type": null,
          "num_comments": 8,
          "send_replies": true,
          "whitelist_status": "all_ads",
          "contest_mode": false,
          "mod_reports": [],
          "author_patreon_flair": false,
          "author_flair_text_color": null,
          "permalink": "/r/haskell/comments/olqe1y/what_are_the_alternatives_for_the_base_type/",
          "parent_whitelist_status": "all_ads",
          "stickied": false,
          "url": "https://www.reddit.com/r/haskell/comments/olqe1y/what_are_the_alternatives_for_the_base_type/",
          "subreddit_subscribers": 64950,
          "created_utc": 1626470670,
          "num_crossposts": 0,
          "media": null,
          "is_video": false
        }
      },
      {
        "kind": "t3",
        "data": {
          "approved_at_utc": null,
          "subreddit": "haskell",
          "selftext": "I recently listened to the following podcast where the guest compared Haskell, Coq etc to the weird stuff you'd see in a [runway show](https://www.pinterest.co.uk/gracecheston/crazy-runway-fashion/), and that its not really meant for everyone one to wear/use (unless I suppose you are [Bjork](https://www.wmagazine.com/gallery/bjork-fashion-style)) but rather to push the envelope. Of course I don't agree in entirety. BTW, Not all runway fashion is impractical ([example](https://www.youtube.com/watch?v=LmGYgZaHhNw)).\n\nhttps://youtu.be/fVv1brAyPss?t=840 (starts at 14:00)",
          "author_fullname": "t2_davb9",
          "saved": false,
          "mod_reason_title": null,
          "gilded": 0,
          "clicked": false,
          "title": "Haskell fashion runway analogy (humorous)",
          "link_flair_richtext": [],
          "subreddit_name_prefixed": "r/haskell",
          "hidden": false,
          "pwls": 6,
          "link_flair_css_class": "",
          "downs": 0,
          "top_awarded_type": null,
          "hide_score": false,
          "name": "t3_olu833",
          "quarantine": false,
          "link_flair_text_color": "light",
          "upvote_ratio": 0.8,
          "author_flair_background_color": null,
          "subreddit_type": "public",
          "ups": 3,
          "total_awards_received": 0,
          "media_embed": {},
          "author_flair_template_id": null,
          "is_original_content": false,
          "user_reports": [],
          "secure_media": null,
          "is_reddit_media_domain": false,
          "is_meta": false,
          "category": null,
          "secure_media_embed": {},
          "link_flair_text": "video",
          "can_mod_post": false,
          "score": 3,
          "approved_by": null,
          "is_created_from_ads_ui": false,
          "author_premium": true,
          "thumbnail": "",
          "edited": 1626483915,
          "author_flair_css_class": null,
          "author_flair_richtext": [],
          "gildings": {},
          "content_categories": null,
          "is_self": true,
          "mod_note": null,
          "created": 1626512410,
          "link_flair_type": "text",
          "wls": 6,
          "removed_by_category": null,
          "banned_by": null,
          "author_flair_type": "text",
          "domain": "self.haskell",
          "allow_live_comments": false,
          "selftext_html": "&lt;!-- SC_OFF --&gt;&lt;div class=\"md\"&gt;&lt;p&gt;I recently listened to the following podcast where the guest compared Haskell, Coq etc to the weird stuff you&amp;#39;d see in a &lt;a href=\"https://www.pinterest.co.uk/gracecheston/crazy-runway-fashion/\"&gt;runway show&lt;/a&gt;, and that its not really meant for everyone one to wear/use (unless I suppose you are &lt;a href=\"https://www.wmagazine.com/gallery/bjork-fashion-style\"&gt;Bjork&lt;/a&gt;) but rather to push the envelope. Of course I don&amp;#39;t agree in entirety. BTW, Not all runway fashion is impractical (&lt;a href=\"https://www.youtube.com/watch?v=LmGYgZaHhNw\"&gt;example&lt;/a&gt;).&lt;/p&gt;\n\n&lt;p&gt;&lt;a href=\"https://youtu.be/fVv1brAyPss?t=840\"&gt;https://youtu.be/fVv1brAyPss?t=840&lt;/a&gt; (starts at 14:00)&lt;/p&gt;\n&lt;/div&gt;&lt;!-- SC_ON --&gt;",
          "likes": null,
          "suggested_sort": null,
          "banned_at_utc": null,
          "view_count": null,
          "archived": false,
          "no_follow": false,
          "is_crosspostable": false,
          "pinned": false,
          "over_18": false,
          "all_awardings": [],
          "awarders": [],
          "media_only": false,
          "link_flair_template_id": "be2af704-5664-11eb-8e65-0ecd290c3053",
          "can_gild": false,
          "spoiler": false,
          "locked": false,
          "author_flair_text": null,
          "treatment_tags": [],
          "visited": false,
          "removed_by": null,
          "num_reports": null,
          "distinguished": null,
          "subreddit_id": "t5_2qh36",
          "mod_reason_by": null,
          "removal_reason": null,
          "link_flair_background_color": "#646d73",
          "id": "olu833",
          "is_robot_indexable": true,
          "report_reasons": null,
          "author": "graphicsRat",
          "discussion_type": null,
          "num_comments": 1,
          "send_replies": true,
          "whitelist_status": "all_ads",
          "contest_mode": false,
          "mod_reports": [],
          "author_patreon_flair": false,
          "author_flair_text_color": null,
          "permalink": "/r/haskell/comments/olu833/haskell_fashion_runway_analogy_humorous/",
          "parent_whitelist_status": "all_ads",
          "stickied": false,
          "url": "https://www.reddit.com/r/haskell/comments/olu833/haskell_fashion_runway_analogy_humorous/",
          "subreddit_subscribers": 64950,
          "created_utc": 1626483610,
          "num_crossposts": 0,
          "media": null,
          "is_video": false
        }
      },
      {
        "kind": "t3",
        "data": {
          "approved_at_utc": null,
          "subreddit": "haskell",
          "selftext": "I am following Get Programming in Haskell by Will Kurt and in Unit1 Ch.5 closures are introduced.\n\nSpecifically Listing 5.5 shows\n\n\\`\\`\\`\n\ngenHostRequestBuilder host =   \n(\\\\apiKey resource id -&gt; getRequestURL host apiKey resource id) \n\nexampleUrlBuilder = genHostRequestBuilder \"http://amazon.com\"\n\ngenApiRequestBuilder hostBuilder apiKey =   \n(\\\\resource id -&gt; hostBuilder apiKey resource id)\n\nmyExampleUrlBuilder = genApiRequestBuilder exampleUrlBuilder \"api-key\"\n\n\\`\\`\\`\n\nwhere closures are being used to make a function that at first accepts host, api key, resource, id as parameters but in the end just the resource and id since the host and api key are often redundant when making api calls to the same site.\n\nMy attempt at the above was different but I'm able to get the correct answer, ie. a valid url to make an api request\n\n\\`\\`\\`\n\nexampleUrlBuilder2 = exampleUrlBuilder \"my-api-key\"\n\n\\`\\`\\`\n\nThus it seems like this closure is overly complicated and in the process I discovered that I can create an alias for a function partially applied to one parameter?  What is the advantage of the textbook's way of using a closure here instead of what I did?",
          "author_fullname": "t2_7bmygxmk",
          "saved": false,
          "mod_reason_title": null,
          "gilded": 0,
          "clicked": false,
          "title": "re: closure seems redundant in Haskell textbook example",
          "link_flair_richtext": [],
          "subreddit_name_prefixed": "r/haskell",
          "hidden": false,
          "pwls": 6,
          "link_flair_css_class": null,
          "downs": 0,
          "top_awarded_type": null,
          "hide_score": false,
          "name": "t3_olp04j",
          "quarantine": false,
          "link_flair_text_color": "dark",
          "upvote_ratio": 0.84,
          "author_flair_background_color": null,
          "subreddit_type": "public",
          "ups": 4,
          "total_awards_received": 0,
          "media_embed": {},
          "author_flair_template_id": null,
          "is_original_content": false,
          "user_reports": [],
          "secure_media": null,
          "is_reddit_media_domain": false,
          "is_meta": false,
          "category": null,
          "secure_media_embed": {},
          "link_flair_text": null,
          "can_mod_post": false,
          "score": 4,
          "approved_by": null,
          "is_created_from_ads_ui": false,
          "author_premium": false,
          "thumbnail": "",
          "edited": false,
          "author_flair_css_class": null,
          "author_flair_richtext": [],
          "gildings": {},
          "content_categories": null,
          "is_self": true,
          "mod_note": null,
          "created": 1626495125,
          "link_flair_type": "text",
          "wls": 6,
          "removed_by_category": null,
          "banned_by": null,
          "author_flair_type": "text",
          "domain": "self.haskell",
          "allow_live_comments": false,
          "selftext_html": "&lt;!-- SC_OFF --&gt;&lt;div class=\"md\"&gt;&lt;p&gt;I am following Get Programming in Haskell by Will Kurt and in Unit1 Ch.5 closures are introduced.&lt;/p&gt;\n\n&lt;p&gt;Specifically Listing 5.5 shows&lt;/p&gt;\n\n&lt;p&gt;```&lt;/p&gt;\n\n&lt;p&gt;genHostRequestBuilder host =&lt;br/&gt;\n(\\apiKey resource id -&amp;gt; getRequestURL host apiKey resource id) &lt;/p&gt;\n\n&lt;p&gt;exampleUrlBuilder = genHostRequestBuilder &amp;quot;&lt;a href=\"http://amazon.com\"&gt;http://amazon.com&lt;/a&gt;&amp;quot;&lt;/p&gt;\n\n&lt;p&gt;genApiRequestBuilder hostBuilder apiKey =&lt;br/&gt;\n(\\resource id -&amp;gt; hostBuilder apiKey resource id)&lt;/p&gt;\n\n&lt;p&gt;myExampleUrlBuilder = genApiRequestBuilder exampleUrlBuilder &amp;quot;api-key&amp;quot;&lt;/p&gt;\n\n&lt;p&gt;```&lt;/p&gt;\n\n&lt;p&gt;where closures are being used to make a function that at first accepts host, api key, resource, id as parameters but in the end just the resource and id since the host and api key are often redundant when making api calls to the same site.&lt;/p&gt;\n\n&lt;p&gt;My attempt at the above was different but I&amp;#39;m able to get the correct answer, ie. a valid url to make an api request&lt;/p&gt;\n\n&lt;p&gt;```&lt;/p&gt;\n\n&lt;p&gt;exampleUrlBuilder2 = exampleUrlBuilder &amp;quot;my-api-key&amp;quot;&lt;/p&gt;\n\n&lt;p&gt;```&lt;/p&gt;\n\n&lt;p&gt;Thus it seems like this closure is overly complicated and in the process I discovered that I can create an alias for a function partially applied to one parameter?  What is the advantage of the textbook&amp;#39;s way of using a closure here instead of what I did?&lt;/p&gt;\n&lt;/div&gt;&lt;!-- SC_ON --&gt;",
          "likes": null,
          "suggested_sort": null,
          "banned_at_utc": null,
          "view_count": null,
          "archived": false,
          "no_follow": false,
          "is_crosspostable": false,
          "pinned": false,
          "over_18": false,
          "all_awardings": [],
          "awarders": [],
          "media_only": false,
          "can_gild": false,
          "spoiler": false,
          "locked": false,
          "author_flair_text": null,
          "treatment_tags": [],
          "visited": false,
          "removed_by": null,
          "num_reports": null,
          "distinguished": null,
          "subreddit_id": "t5_2qh36",
          "mod_reason_by": null,
          "removal_reason": null,
          "link_flair_background_color": "",
          "id": "olp04j",
          "is_robot_indexable": true,
          "report_reasons": null,
          "author": "webNoob13",
          "discussion_type": null,
          "num_comments": 4,
          "send_replies": true,
          "whitelist_status": "all_ads",
          "contest_mode": false,
          "mod_reports": [],
          "author_patreon_flair": false,
          "author_flair_text_color": null,
          "permalink": "/r/haskell/comments/olp04j/re_closure_seems_redundant_in_haskell_textbook/",
          "parent_whitelist_status": "all_ads",
          "stickied": false,
          "url": "https://www.reddit.com/r/haskell/comments/olp04j/re_closure_seems_redundant_in_haskell_textbook/",
          "subreddit_subscribers": 64950,
          "created_utc": 1626466325,
          "num_crossposts": 0,
          "media": null,
          "is_video": false
        }
      },
      {
        "kind": "t3",
        "data": {
          "approved_at_utc": null,
          "subreddit": "haskell",
          "selftext": "Normally `take :: Int -&gt; [a] -&gt; [a]` takes the specified number of elements or less, if the list appeared shorter than expected. Now if you wish to distinguish between these cases, you need to check that `length (take n xs) == n`. This is wasteful.\n\nI'd like to define `takeFoo :: Int -&gt; [a] -&gt; (Int, [a])`, which tells immediately how many elements were successfully taken. What is the best name for such function?\n\n(If you are wondering about my context, this is actually not about lists, but about `Text`, where `length` is very expensive).",
          "author_fullname": "t2_qou7f",
          "saved": false,
          "mod_reason_title": null,
          "gilded": 0,
          "clicked": false,
          "title": "How would you call take :: Int -&gt; [a] -&gt; (Int, [a]), which returns number of elements taken?",
          "link_flair_richtext": [],
          "subreddit_name_prefixed": "r/haskell",
          "hidden": false,
          "pwls": 6,
          "link_flair_css_class": null,
          "downs": 0,
          "top_awarded_type": null,
          "hide_score": false,
          "name": "t3_olo9n1",
          "quarantine": false,
          "link_flair_text_color": "dark",
          "upvote_ratio": 0.8,
          "author_flair_background_color": null,
          "subreddit_type": "public",
          "ups": 3,
          "total_awards_received": 0,
          "media_embed": {},
          "author_flair_template_id": null,
          "is_original_content": false,
          "user_reports": [],
          "secure_media": null,
          "is_reddit_media_domain": false,
          "is_meta": false,
          "category": null,
          "secure_media_embed": {},
          "link_flair_text": null,
          "can_mod_post": false,
          "score": 3,
          "approved_by": null,
          "is_created_from_ads_ui": false,
          "author_premium": false,
          "thumbnail": "",
          "edited": 1626464509,
          "author_flair_css_class": null,
          "author_flair_richtext": [],
          "gildings": {},
          "content_categories": null,
          "is_self": true,
          "mod_note": null,
          "created": 1626492945,
          "link_flair_type": "text",
          "wls": 6,
          "removed_by_category": null,
          "banned_by": null,
          "author_flair_type": "text",
          "domain": "self.haskell",
          "allow_live_comments": false,
          "selftext_html": "&lt;!-- SC_OFF --&gt;&lt;div class=\"md\"&gt;&lt;p&gt;Normally &lt;code&gt;take :: Int -&amp;gt; [a] -&amp;gt; [a]&lt;/code&gt; takes the specified number of elements or less, if the list appeared shorter than expected. Now if you wish to distinguish between these cases, you need to check that &lt;code&gt;length (take n xs) == n&lt;/code&gt;. This is wasteful.&lt;/p&gt;\n\n&lt;p&gt;I&amp;#39;d like to define &lt;code&gt;takeFoo :: Int -&amp;gt; [a] -&amp;gt; (Int, [a])&lt;/code&gt;, which tells immediately how many elements were successfully taken. What is the best name for such function?&lt;/p&gt;\n\n&lt;p&gt;(If you are wondering about my context, this is actually not about lists, but about &lt;code&gt;Text&lt;/code&gt;, where &lt;code&gt;length&lt;/code&gt; is very expensive).&lt;/p&gt;\n&lt;/div&gt;&lt;!-- SC_ON --&gt;",
          "likes": null,
          "suggested_sort": null,
          "banned_at_utc": null,
          "view_count": null,
          "archived": false,
          "no_follow": false,
          "is_crosspostable": false,
          "pinned": false,
          "over_18": false,
          "all_awardings": [],
          "awarders": [],
          "media_only": false,
          "can_gild": false,
          "spoiler": false,
          "locked": false,
          "author_flair_text": null,
          "treatment_tags": [],
          "visited": false,
          "removed_by": null,
          "num_reports": null,
          "distinguished": null,
          "subreddit_id": "t5_2qh36",
          "mod_reason_by": null,
          "removal_reason": null,
          "link_flair_background_color": "",
          "id": "olo9n1",
          "is_robot_indexable": true,
          "report_reasons": null,
          "author": "Bodigrim",
          "discussion_type": null,
          "num_comments": 15,
          "send_replies": true,
          "whitelist_status": "all_ads",
          "contest_mode": false,
          "mod_reports": [],
          "author_patreon_flair": false,
          "author_flair_text_color": null,
          "permalink": "/r/haskell/comments/olo9n1/how_would_you_call_take_int_a_int_a_which_returns/",
          "parent_whitelist_status": "all_ads",
          "stickied": false,
          "url": "https://www.reddit.com/r/haskell/comments/olo9n1/how_would_you_call_take_int_a_int_a_which_returns/",
          "subreddit_subscribers": 64950,
          "created_utc": 1626464145,
          "num_crossposts": 0,
          "media": null,
          "is_video": false
        }
      },
      {
        "kind": "t3",
        "data": {
          "approved_at_utc": null,
          "subreddit": "haskell",
          "selftext": "",
          "author_fullname": "t2_1r5quhg",
          "saved": false,
          "mod_reason_title": null,
          "gilded": 0,
          "clicked": false,
          "title": "As a programmer whoâ€™s explicitly only dealt with Python and is now attempting to learn Haskell, this video is one of the most beautifully presented videos explaining the use of Lamba Calculus in settings where languages such as JavaScript would be implemented.",
          "link_flair_richtext": [],
          "subreddit_name_prefixed": "r/haskell",
          "hidden": false,
          "pwls": 6,
          "link_flair_css_class": "",
          "downs": 0,
          "top_awarded_type": null,
          "hide_score": false,
          "name": "t3_ol7r34",
          "quarantine": false,
          "link_flair_text_color": "light",
          "upvote_ratio": 0.95,
          "author_flair_background_color": null,
          "subreddit_type": "public",
          "ups": 68,
          "total_awards_received": 0,
          "media_embed": {
            "content": "&lt;iframe width=\"356\" height=\"200\" src=\"https://www.youtube.com/embed/3VQ382QG-y4?feature=oembed&amp;enablejsapi=1\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen&gt;&lt;/iframe&gt;",
            "width": 356,
            "scrolling": false,
            "height": 200
          },
          "author_flair_template_id": null,
          "is_original_content": false,
          "user_reports": [],
          "secure_media": {
            "type": "youtube.com",
            "oembed": {
              "provider_url": "https://www.youtube.com/",
              "version": "1.0",
              "title": "Lambda Calculus - Fundamentals of Lambda Calculus &amp; Functional Programming in JavaScript",
              "type": "video",
              "thumbnail_width": 480,
              "height": 200,
              "width": 356,
              "html": "&lt;iframe width=\"356\" height=\"200\" src=\"https://www.youtube.com/embed/3VQ382QG-y4?feature=oembed&amp;enablejsapi=1\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen&gt;&lt;/iframe&gt;",
              "author_name": "Fullstack Academy",
              "provider_name": "YouTube",
              "thumbnail_url": "https://i.ytimg.com/vi/3VQ382QG-y4/hqdefault.jpg",
              "thumbnail_height": 360,
              "author_url": "https://www.youtube.com/c/FullstackAcademyOfCode"
            }
          },
          "is_reddit_media_domain": false,
          "is_meta": false,
          "category": null,
          "secure_media_embed": {
            "content": "&lt;iframe width=\"356\" height=\"200\" src=\"https://www.youtube.com/embed/3VQ382QG-y4?feature=oembed&amp;enablejsapi=1\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen&gt;&lt;/iframe&gt;",
            "width": 356,
            "scrolling": false,
            "media_domain_url": "https://www.redditmedia.com/mediaembed/ol7r34",
            "height": 200
          },
          "link_flair_text": "video",
          "can_mod_post": false,
          "score": 68,
          "approved_by": null,
          "is_created_from_ads_ui": false,
          "author_premium": false,
          "thumbnail": "",
          "edited": false,
          "author_flair_css_class": null,
          "author_flair_richtext": [],
          "gildings": {},
          "content_categories": null,
          "is_self": false,
          "mod_note": null,
          "created": 1626431824,
          "link_flair_type": "text",
          "wls": 6,
          "removed_by_category": null,
          "banned_by": null,
          "author_flair_type": "text",
          "domain": "youtu.be",
          "allow_live_comments": false,
          "selftext_html": null,
          "likes": null,
          "suggested_sort": null,
          "banned_at_utc": null,
          "url_overridden_by_dest": "https://youtu.be/3VQ382QG-y4",
          "view_count": null,
          "archived": false,
          "no_follow": false,
          "is_crosspostable": false,
          "pinned": false,
          "over_18": false,
          "all_awardings": [],
          "awarders": [],
          "media_only": false,
          "link_flair_template_id": "be2af704-5664-11eb-8e65-0ecd290c3053",
          "can_gild": false,
          "spoiler": false,
          "locked": false,
          "author_flair_text": null,
          "treatment_tags": [],
          "visited": false,
          "removed_by": null,
          "num_reports": null,
          "distinguished": null,
          "subreddit_id": "t5_2qh36",
          "mod_reason_by": null,
          "removal_reason": null,
          "link_flair_background_color": "#646d73",
          "id": "ol7r34",
          "is_robot_indexable": true,
          "report_reasons": null,
          "author": "anotherexstnslcrisis",
          "discussion_type": null,
          "num_comments": 7,
          "send_replies": true,
          "whitelist_status": "all_ads",
          "contest_mode": false,
          "mod_reports": [],
          "author_patreon_flair": false,
          "author_flair_text_color": null,
          "permalink": "/r/haskell/comments/ol7r34/as_a_programmer_whos_explicitly_only_dealt_with/",
          "parent_whitelist_status": "all_ads",
          "stickied": false,
          "url": "https://youtu.be/3VQ382QG-y4",
          "subreddit_subscribers": 64950,
          "created_utc": 1626403024,
          "num_crossposts": 0,
          "media": {
            "type": "youtube.com",
            "oembed": {
              "provider_url": "https://www.youtube.com/",
              "version": "1.0",
              "title": "Lambda Calculus - Fundamentals of Lambda Calculus &amp; Functional Programming in JavaScript",
              "type": "video",
              "thumbnail_width": 480,
              "height": 200,
              "width": 356,
              "html": "&lt;iframe width=\"356\" height=\"200\" src=\"https://www.youtube.com/embed/3VQ382QG-y4?feature=oembed&amp;enablejsapi=1\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen&gt;&lt;/iframe&gt;",
              "author_name": "Fullstack Academy",
              "provider_name": "YouTube",
              "thumbnail_url": "https://i.ytimg.com/vi/3VQ382QG-y4/hqdefault.jpg",
              "thumbnail_height": 360,
              "author_url": "https://www.youtube.com/c/FullstackAcademyOfCode"
            }
          },
          "is_video": false
        }
      },
      {
        "kind": "t3",
        "data": {
          "approved_at_utc": null,
          "subreddit": "haskell",
          "selftext": "[Here](https://wiki.haskell.org/Newtype) is a discussion of `newtype`. Note \n\n    newtype State s a = State { runState :: s -&gt; (s, a) }\n\nAnd then later\n\n    State :: (s -&gt; (s, a)) -&gt; State s a\n    runState :: State s a -&gt; (s -&gt; (s, a))\n\nwhich I assume are only the type id's from doing `:t`. Good. And I think I understand that since `s -&gt; (s, a)` , i.e., `(s, a)` is a tuple, we are not violating the one-parameter restriction of a `newtype`. But what does `s -&gt; (s, a)`  mean, i.e., what is a function doing in a type declaration? I'm afraid I've never run across this before. Also, what could this type be used for?",
          "author_fullname": "t2_a8zynd1e",
          "saved": false,
          "mod_reason_title": null,
          "gilded": 0,
          "clicked": false,
          "title": "What does this newtype do?",
          "link_flair_richtext": [],
          "subreddit_name_prefixed": "r/haskell",
          "hidden": false,
          "pwls": 6,
          "link_flair_css_class": null,
          "downs": 0,
          "top_awarded_type": null,
          "hide_score": false,
          "name": "t3_ol98n7",
          "quarantine": false,
          "link_flair_text_color": "dark",
          "upvote_ratio": 0.72,
          "author_flair_background_color": null,
          "subreddit_type": "public",
          "ups": 3,
          "total_awards_received": 0,
          "media_embed": {},
          "author_flair_template_id": null,
          "is_original_content": false,
          "user_reports": [],
          "secure_media": null,
          "is_reddit_media_domain": false,
          "is_meta": false,
          "category": null,
          "secure_media_embed": {},
          "link_flair_text": null,
          "can_mod_post": false,
          "score": 3,
          "approved_by": null,
          "is_created_from_ads_ui": false,
          "author_premium": false,
          "thumbnail": "",
          "edited": false,
          "author_flair_css_class": null,
          "author_flair_richtext": [],
          "gildings": {},
          "content_categories": null,
          "is_self": true,
          "mod_note": null,
          "created": 1626437431,
          "link_flair_type": "text",
          "wls": 6,
          "removed_by_category": null,
          "banned_by": null,
          "author_flair_type": "text",
          "domain": "self.haskell",
          "allow_live_comments": false,
          "selftext_html": "&lt;!-- SC_OFF --&gt;&lt;div class=\"md\"&gt;&lt;p&gt;&lt;a href=\"https://wiki.haskell.org/Newtype\"&gt;Here&lt;/a&gt; is a discussion of &lt;code&gt;newtype&lt;/code&gt;. Note &lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;newtype State s a = State { runState :: s -&amp;gt; (s, a) }\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;And then later&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;State :: (s -&amp;gt; (s, a)) -&amp;gt; State s a\nrunState :: State s a -&amp;gt; (s -&amp;gt; (s, a))\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;which I assume are only the type id&amp;#39;s from doing &lt;code&gt;:t&lt;/code&gt;. Good. And I think I understand that since &lt;code&gt;s -&amp;gt; (s, a)&lt;/code&gt; , i.e., &lt;code&gt;(s, a)&lt;/code&gt; is a tuple, we are not violating the one-parameter restriction of a &lt;code&gt;newtype&lt;/code&gt;. But what does &lt;code&gt;s -&amp;gt; (s, a)&lt;/code&gt;  mean, i.e., what is a function doing in a type declaration? I&amp;#39;m afraid I&amp;#39;ve never run across this before. Also, what could this type be used for?&lt;/p&gt;\n&lt;/div&gt;&lt;!-- SC_ON --&gt;",
          "likes": null,
          "suggested_sort": null,
          "banned_at_utc": null,
          "view_count": null,
          "archived": false,
          "no_follow": false,
          "is_crosspostable": false,
          "pinned": false,
          "over_18": false,
          "all_awardings": [],
          "awarders": [],
          "media_only": false,
          "can_gild": false,
          "spoiler": false,
          "locked": false,
          "author_flair_text": null,
          "treatment_tags": [],
          "visited": false,
          "removed_by": null,
          "num_reports": null,
          "distinguished": null,
          "subreddit_id": "t5_2qh36",
          "mod_reason_by": null,
          "removal_reason": null,
          "link_flair_background_color": "",
          "id": "ol98n7",
          "is_robot_indexable": true,
          "report_reasons": null,
          "author": "teilchen010",
          "discussion_type": null,
          "num_comments": 13,
          "send_replies": true,
          "whitelist_status": "all_ads",
          "contest_mode": false,
          "mod_reports": [],
          "author_patreon_flair": false,
          "author_flair_text_color": null,
          "permalink": "/r/haskell/comments/ol98n7/what_does_this_newtype_do/",
          "parent_whitelist_status": "all_ads",
          "stickied": false,
          "url": "https://www.reddit.com/r/haskell/comments/ol98n7/what_does_this_newtype_do/",
          "subreddit_subscribers": 64950,
          "created_utc": 1626408631,
          "num_crossposts": 0,
          "media": null,
          "is_video": false
        }
      },
      {
        "kind": "t3",
        "data": {
          "approved_at_utc": null,
          "subreddit": "haskell",
          "selftext": "Hi all, some folks here might be interested in a new Haskell MVC web framework that we've built\n\n[https://storm-framework.github.io/](https://storm-framework.github.io/)\n\n**STORM** lets you write expressive and auditable [security policies](https://storm-framework.github.io/policies.html) with the data model. The policies are enforced via compile-time refinement type checking with [LiquidHaskell](https://ucsd-progsys.github.io/liquidhaskell-blog).",
          "author_fullname": "t2_51loi",
          "saved": false,
          "mod_reason_title": null,
          "gilded": 0,
          "clicked": false,
          "title": "STORM: Enforcing Security Policies in Web Apps with LiquidHaskell",
          "link_flair_richtext": [],
          "subreddit_name_prefixed": "r/haskell",
          "hidden": false,
          "pwls": 6,
          "link_flair_css_class": null,
          "downs": 0,
          "top_awarded_type": null,
          "hide_score": false,
          "name": "t3_okuzmq",
          "quarantine": false,
          "link_flair_text_color": "dark",
          "upvote_ratio": 0.97,
          "author_flair_background_color": null,
          "subreddit_type": "public",
          "ups": 41,
          "total_awards_received": 0,
          "media_embed": {},
          "author_flair_template_id": null,
          "is_original_content": false,
          "user_reports": [],
          "secure_media": null,
          "is_reddit_media_domain": false,
          "is_meta": false,
          "category": null,
          "secure_media_embed": {},
          "link_flair_text": null,
          "can_mod_post": false,
          "score": 41,
          "approved_by": null,
          "is_created_from_ads_ui": false,
          "author_premium": false,
          "thumbnail": "",
          "edited": false,
          "author_flair_css_class": null,
          "author_flair_richtext": [],
          "gildings": {},
          "content_categories": null,
          "is_self": true,
          "mod_note": null,
          "created": 1626391210,
          "link_flair_type": "text",
          "wls": 6,
          "removed_by_category": null,
          "banned_by": null,
          "author_flair_type": "text",
          "domain": "self.haskell",
          "allow_live_comments": false,
          "selftext_html": "&lt;!-- SC_OFF --&gt;&lt;div class=\"md\"&gt;&lt;p&gt;Hi all, some folks here might be interested in a new Haskell MVC web framework that we&amp;#39;ve built&lt;/p&gt;\n\n&lt;p&gt;&lt;a href=\"https://storm-framework.github.io/\"&gt;https://storm-framework.github.io/&lt;/a&gt;&lt;/p&gt;\n\n&lt;p&gt;&lt;strong&gt;STORM&lt;/strong&gt; lets you write expressive and auditable &lt;a href=\"https://storm-framework.github.io/policies.html\"&gt;security policies&lt;/a&gt; with the data model. The policies are enforced via compile-time refinement type checking with &lt;a href=\"https://ucsd-progsys.github.io/liquidhaskell-blog\"&gt;LiquidHaskell&lt;/a&gt;.&lt;/p&gt;\n&lt;/div&gt;&lt;!-- SC_ON --&gt;",
          "likes": null,
          "suggested_sort": null,
          "banned_at_utc": null,
          "view_count": null,
          "archived": false,
          "no_follow": false,
          "is_crosspostable": false,
          "pinned": false,
          "over_18": false,
          "all_awardings": [],
          "awarders": [],
          "media_only": false,
          "can_gild": false,
          "spoiler": false,
          "locked": false,
          "author_flair_text": null,
          "treatment_tags": [],
          "visited": false,
          "removed_by": null,
          "num_reports": null,
          "distinguished": null,
          "subreddit_id": "t5_2qh36",
          "mod_reason_by": null,
          "removal_reason": null,
          "link_flair_background_color": "",
          "id": "okuzmq",
          "is_robot_indexable": true,
          "report_reasons": null,
          "author": "ranjitjhala",
          "discussion_type": null,
          "num_comments": 5,
          "send_replies": true,
          "whitelist_status": "all_ads",
          "contest_mode": false,
          "mod_reports": [],
          "author_patreon_flair": false,
          "author_flair_text_color": null,
          "permalink": "/r/haskell/comments/okuzmq/storm_enforcing_security_policies_in_web_apps/",
          "parent_whitelist_status": "all_ads",
          "stickied": false,
          "url": "https://www.reddit.com/r/haskell/comments/okuzmq/storm_enforcing_security_policies_in_web_apps/",
          "subreddit_subscribers": 64950,
          "created_utc": 1626362410,
          "num_crossposts": 0,
          "media": null,
          "is_video": false
        }
      },
      {
        "kind": "t3",
        "data": {
          "approved_at_utc": null,
          "subreddit": "haskell",
          "selftext": "[https://easyapply.co/a/db21a8ed-6cb9-44e9-b549-7cb1302bf608?rcid=applynow](https://easyapply.co/a/db21a8ed-6cb9-44e9-b549-7cb1302bf608?rcid=applynow)\n\nOr just send resume to vverdi at [masterword.com](https://masterword.com)",
          "author_fullname": "t2_1uf6",
          "saved": false,
          "mod_reason_title": null,
          "gilded": 0,
          "clicked": false,
          "title": "Haskell Job offer, Houston, TX, remote work.",
          "link_flair_richtext": [],
          "subreddit_name_prefixed": "r/haskell",
          "hidden": false,
          "pwls": 6,
          "link_flair_css_class": "",
          "downs": 0,
          "top_awarded_type": null,
          "hide_score": false,
          "name": "t3_okvrls",
          "quarantine": false,
          "link_flair_text_color": "light",
          "upvote_ratio": 0.86,
          "author_flair_background_color": null,
          "subreddit_type": "public",
          "ups": 16,
          "total_awards_received": 0,
          "media_embed": {},
          "author_flair_template_id": null,
          "is_original_content": false,
          "user_reports": [],
          "secure_media": null,
          "is_reddit_media_domain": false,
          "is_meta": false,
          "category": null,
          "secure_media_embed": {},
          "link_flair_text": "job",
          "can_mod_post": false,
          "score": 16,
          "approved_by": null,
          "is_created_from_ads_ui": false,
          "author_premium": false,
          "thumbnail": "",
          "edited": false,
          "author_flair_css_class": null,
          "author_flair_richtext": [],
          "gildings": {},
          "content_categories": null,
          "is_self": true,
          "mod_note": null,
          "created": 1626393537,
          "link_flair_type": "text",
          "wls": 6,
          "removed_by_category": null,
          "banned_by": null,
          "author_flair_type": "text",
          "domain": "self.haskell",
          "allow_live_comments": false,
          "selftext_html": "&lt;!-- SC_OFF --&gt;&lt;div class=\"md\"&gt;&lt;p&gt;&lt;a href=\"https://easyapply.co/a/db21a8ed-6cb9-44e9-b549-7cb1302bf608?rcid=applynow\"&gt;https://easyapply.co/a/db21a8ed-6cb9-44e9-b549-7cb1302bf608?rcid=applynow&lt;/a&gt;&lt;/p&gt;\n\n&lt;p&gt;Or just send resume to vverdi at &lt;a href=\"https://masterword.com\"&gt;masterword.com&lt;/a&gt;&lt;/p&gt;\n&lt;/div&gt;&lt;!-- SC_ON --&gt;",
          "likes": null,
          "suggested_sort": null,
          "banned_at_utc": null,
          "view_count": null,
          "archived": false,
          "no_follow": false,
          "is_crosspostable": false,
          "pinned": false,
          "over_18": false,
          "all_awardings": [],
          "awarders": [],
          "media_only": false,
          "link_flair_template_id": "e937232e-16d0-11eb-89ac-0ee006d12603",
          "can_gild": false,
          "spoiler": false,
          "locked": false,
          "author_flair_text": null,
          "treatment_tags": [],
          "visited": false,
          "removed_by": null,
          "num_reports": null,
          "distinguished": null,
          "subreddit_id": "t5_2qh36",
          "mod_reason_by": null,
          "removal_reason": null,
          "link_flair_background_color": "#646d73",
          "id": "okvrls",
          "is_robot_indexable": true,
          "report_reasons": null,
          "author": "vagif",
          "discussion_type": null,
          "num_comments": 0,
          "send_replies": true,
          "whitelist_status": "all_ads",
          "contest_mode": false,
          "mod_reports": [],
          "author_patreon_flair": false,
          "author_flair_text_color": null,
          "permalink": "/r/haskell/comments/okvrls/haskell_job_offer_houston_tx_remote_work/",
          "parent_whitelist_status": "all_ads",
          "stickied": false,
          "url": "https://www.reddit.com/r/haskell/comments/okvrls/haskell_job_offer_houston_tx_remote_work/",
          "subreddit_subscribers": 64950,
          "created_utc": 1626364737,
          "num_crossposts": 0,
          "media": null,
          "is_video": false
        }
      },
      {
        "kind": "t3",
        "data": {
          "approved_at_utc": null,
          "subreddit": "haskell",
          "selftext": "**Did you know?**\n\nThe  first Plutus Pioneer Program had 1,500 students. The second cohort is  underway with over 2,800 students learning to code both Plutus and  Haskell programming languages.\n\nPlutus is based on Haskell and will be used to create smart contracts on Cardano.",
          "author_fullname": "t2_2c3y1k8m",
          "saved": false,
          "mod_reason_title": null,
          "gilded": 0,
          "clicked": false,
          "title": "Plutus Pioneer Program has 4K+ Students",
          "link_flair_richtext": [],
          "subreddit_name_prefixed": "r/haskell",
          "hidden": false,
          "pwls": 6,
          "link_flair_css_class": "",
          "downs": 0,
          "top_awarded_type": null,
          "hide_score": false,
          "name": "t3_olkj99",
          "quarantine": false,
          "link_flair_text_color": "light",
          "upvote_ratio": 0.36,
          "author_flair_background_color": null,
          "subreddit_type": "public",
          "ups": 0,
          "total_awards_received": 0,
          "media_embed": {},
          "author_flair_template_id": null,
          "is_original_content": false,
          "user_reports": [],
          "secure_media": null,
          "is_reddit_media_domain": false,
          "is_meta": false,
          "category": null,
          "secure_media_embed": {},
          "link_flair_text": "job",
          "can_mod_post": false,
          "score": 0,
          "approved_by": null,
          "is_created_from_ads_ui": false,
          "author_premium": true,
          "thumbnail": "",
          "edited": 1626455008,
          "author_flair_css_class": null,
          "author_flair_richtext": [],
          "gildings": {},
          "content_categories": null,
          "is_self": true,
          "mod_note": null,
          "created": 1626482196,
          "link_flair_type": "text",
          "wls": 6,
          "removed_by_category": null,
          "banned_by": null,
          "author_flair_type": "text",
          "domain": "self.haskell",
          "allow_live_comments": false,
          "selftext_html": "&lt;!-- SC_OFF --&gt;&lt;div class=\"md\"&gt;&lt;p&gt;&lt;strong&gt;Did you know?&lt;/strong&gt;&lt;/p&gt;\n\n&lt;p&gt;The  first Plutus Pioneer Program had 1,500 students. The second cohort is  underway with over 2,800 students learning to code both Plutus and  Haskell programming languages.&lt;/p&gt;\n\n&lt;p&gt;Plutus is based on Haskell and will be used to create smart contracts on Cardano.&lt;/p&gt;\n&lt;/div&gt;&lt;!-- SC_ON --&gt;",
          "likes": null,
          "suggested_sort": null,
          "banned_at_utc": null,
          "view_count": null,
          "archived": false,
          "no_follow": true,
          "is_crosspostable": false,
          "pinned": false,
          "over_18": false,
          "all_awardings": [],
          "awarders": [],
          "media_only": false,
          "link_flair_template_id": "e937232e-16d0-11eb-89ac-0ee006d12603",
          "can_gild": false,
          "spoiler": false,
          "locked": false,
          "author_flair_text": null,
          "treatment_tags": [],
          "visited": false,
          "removed_by": null,
          "num_reports": null,
          "distinguished": null,
          "subreddit_id": "t5_2qh36",
          "mod_reason_by": null,
          "removal_reason": null,
          "link_flair_background_color": "#646d73",
          "id": "olkj99",
          "is_robot_indexable": true,
          "report_reasons": null,
          "author": "sillychillly",
          "discussion_type": null,
          "num_comments": 0,
          "send_replies": true,
          "whitelist_status": "all_ads",
          "contest_mode": false,
          "mod_reports": [],
          "author_patreon_flair": false,
          "author_flair_text_color": null,
          "permalink": "/r/haskell/comments/olkj99/plutus_pioneer_program_has_4k_students/",
          "parent_whitelist_status": "all_ads",
          "stickied": false,
          "url": "https://www.reddit.com/r/haskell/comments/olkj99/plutus_pioneer_program_has_4k_students/",
          "subreddit_subscribers": 64950,
          "created_utc": 1626453396,
          "num_crossposts": 0,
          "media": null,
          "is_video": false
        }
      },
      {
        "kind": "t3",
        "data": {
          "approved_at_utc": null,
          "subreddit": "haskell",
          "selftext": "For a project I'm working on, I need to parse existing Haskell files into some representation that is able to process them. In a perfect world, there would just be a library that allows for a deep embedding of Haskell inside Haskell. Does something like this exist?\n\nMaybe I could use parts of ghcide or hls, since they obviously need some way of working with source code, though I don't know if that's possible. (and in case it is, if it's a good idea)\n\nMaybe something like this could be done in template Haskell, but  I don't know a lot about TH.\n\nA library that compiles haskell down to System FC would also be fine, though not perfect since I  later need to generate haskell.\n\nHas anybody had a similar task?\n\nHow did you solve it?\n\nThanks in advance!",
          "author_fullname": "t2_gvx3a",
          "saved": false,
          "mod_reason_title": null,
          "gilded": 0,
          "clicked": false,
          "title": "Deep embedding of Haskell in Haskell",
          "link_flair_richtext": [],
          "subreddit_name_prefixed": "r/haskell",
          "hidden": false,
          "pwls": 6,
          "link_flair_css_class": null,
          "downs": 0,
          "top_awarded_type": null,
          "hide_score": false,
          "name": "t3_okwmrx",
          "quarantine": false,
          "link_flair_text_color": "dark",
          "upvote_ratio": 0.88,
          "author_flair_background_color": null,
          "subreddit_type": "public",
          "ups": 6,
          "total_awards_received": 0,
          "media_embed": {},
          "author_flair_template_id": null,
          "is_original_content": false,
          "user_reports": [],
          "secure_media": null,
          "is_reddit_media_domain": false,
          "is_meta": false,
          "category": null,
          "secure_media_embed": {},
          "link_flair_text": null,
          "can_mod_post": false,
          "score": 6,
          "approved_by": null,
          "is_created_from_ads_ui": false,
          "author_premium": false,
          "thumbnail": "",
          "edited": false,
          "author_flair_css_class": null,
          "author_flair_richtext": [],
          "gildings": {},
          "content_categories": null,
          "is_self": true,
          "mod_note": null,
          "created": 1626396086,
          "link_flair_type": "text",
          "wls": 6,
          "removed_by_category": null,
          "banned_by": null,
          "author_flair_type": "text",
          "domain": "self.haskell",
          "allow_live_comments": false,
          "selftext_html": "&lt;!-- SC_OFF --&gt;&lt;div class=\"md\"&gt;&lt;p&gt;For a project I&amp;#39;m working on, I need to parse existing Haskell files into some representation that is able to process them. In a perfect world, there would just be a library that allows for a deep embedding of Haskell inside Haskell. Does something like this exist?&lt;/p&gt;\n\n&lt;p&gt;Maybe I could use parts of ghcide or hls, since they obviously need some way of working with source code, though I don&amp;#39;t know if that&amp;#39;s possible. (and in case it is, if it&amp;#39;s a good idea)&lt;/p&gt;\n\n&lt;p&gt;Maybe something like this could be done in template Haskell, but  I don&amp;#39;t know a lot about TH.&lt;/p&gt;\n\n&lt;p&gt;A library that compiles haskell down to System FC would also be fine, though not perfect since I  later need to generate haskell.&lt;/p&gt;\n\n&lt;p&gt;Has anybody had a similar task?&lt;/p&gt;\n\n&lt;p&gt;How did you solve it?&lt;/p&gt;\n\n&lt;p&gt;Thanks in advance!&lt;/p&gt;\n&lt;/div&gt;&lt;!-- SC_ON --&gt;",
          "likes": null,
          "suggested_sort": null,
          "banned_at_utc": null,
          "view_count": null,
          "archived": false,
          "no_follow": false,
          "is_crosspostable": false,
          "pinned": false,
          "over_18": false,
          "all_awardings": [],
          "awarders": [],
          "media_only": false,
          "can_gild": false,
          "spoiler": false,
          "locked": false,
          "author_flair_text": null,
          "treatment_tags": [],
          "visited": false,
          "removed_by": null,
          "num_reports": null,
          "distinguished": null,
          "subreddit_id": "t5_2qh36",
          "mod_reason_by": null,
          "removal_reason": null,
          "link_flair_background_color": "",
          "id": "okwmrx",
          "is_robot_indexable": true,
          "report_reasons": null,
          "author": "MattAlex99",
          "discussion_type": null,
          "num_comments": 9,
          "send_replies": true,
          "whitelist_status": "all_ads",
          "contest_mode": false,
          "mod_reports": [],
          "author_patreon_flair": false,
          "author_flair_text_color": null,
          "permalink": "/r/haskell/comments/okwmrx/deep_embedding_of_haskell_in_haskell/",
          "parent_whitelist_status": "all_ads",
          "stickied": false,
          "url": "https://www.reddit.com/r/haskell/comments/okwmrx/deep_embedding_of_haskell_in_haskell/",
          "subreddit_subscribers": 64950,
          "created_utc": 1626367286,
          "num_crossposts": 0,
          "media": null,
          "is_video": false
        }
      },
      {
        "kind": "t3",
        "data": {
          "approved_at_utc": null,
          "subreddit": "haskell",
          "selftext": "I am trying to learn Haskell. And thought that it would be a good idea to be able to use VS Code for simple code writing during the process of learning.\n\nHas anybody else faced this? I would think that ideally I should point VS Code extension to the Haskell-stack installed GHC. Not sure how and don't know if that is ideal or unnecessary.\n\nComments?",
          "author_fullname": "t2_b0iepq",
          "saved": false,
          "mod_reason_title": null,
          "gilded": 0,
          "clicked": false,
          "title": "installed Haskell-stack using brew, and VS Code Haskell extension wants to install GHC again",
          "link_flair_richtext": [],
          "subreddit_name_prefixed": "r/haskell",
          "hidden": false,
          "pwls": 6,
          "link_flair_css_class": null,
          "downs": 0,
          "top_awarded_type": null,
          "hide_score": false,
          "name": "t3_oku7sn",
          "quarantine": false,
          "link_flair_text_color": "dark",
          "upvote_ratio": 1,
          "author_flair_background_color": null,
          "subreddit_type": "public",
          "ups": 9,
          "total_awards_received": 0,
          "media_embed": {},
          "author_flair_template_id": null,
          "is_original_content": false,
          "user_reports": [],
          "secure_media": null,
          "is_reddit_media_domain": false,
          "is_meta": false,
          "category": null,
          "secure_media_embed": {},
          "link_flair_text": null,
          "can_mod_post": false,
          "score": 9,
          "approved_by": null,
          "is_created_from_ads_ui": false,
          "author_premium": false,
          "thumbnail": "",
          "edited": false,
          "author_flair_css_class": null,
          "author_flair_richtext": [],
          "gildings": {},
          "content_categories": null,
          "is_self": true,
          "mod_note": null,
          "created": 1626388914,
          "link_flair_type": "text",
          "wls": 6,
          "removed_by_category": null,
          "banned_by": null,
          "author_flair_type": "text",
          "domain": "self.haskell",
          "allow_live_comments": false,
          "selftext_html": "&lt;!-- SC_OFF --&gt;&lt;div class=\"md\"&gt;&lt;p&gt;I am trying to learn Haskell. And thought that it would be a good idea to be able to use VS Code for simple code writing during the process of learning.&lt;/p&gt;\n\n&lt;p&gt;Has anybody else faced this? I would think that ideally I should point VS Code extension to the Haskell-stack installed GHC. Not sure how and don&amp;#39;t know if that is ideal or unnecessary.&lt;/p&gt;\n\n&lt;p&gt;Comments?&lt;/p&gt;\n&lt;/div&gt;&lt;!-- SC_ON --&gt;",
          "likes": null,
          "suggested_sort": null,
          "banned_at_utc": null,
          "view_count": null,
          "archived": false,
          "no_follow": false,
          "is_crosspostable": false,
          "pinned": false,
          "over_18": false,
          "all_awardings": [],
          "awarders": [],
          "media_only": false,
          "can_gild": false,
          "spoiler": false,
          "locked": false,
          "author_flair_text": null,
          "treatment_tags": [],
          "visited": false,
          "removed_by": null,
          "num_reports": null,
          "distinguished": null,
          "subreddit_id": "t5_2qh36",
          "mod_reason_by": null,
          "removal_reason": null,
          "link_flair_background_color": "",
          "id": "oku7sn",
          "is_robot_indexable": true,
          "report_reasons": null,
          "author": "redd-sm",
          "discussion_type": null,
          "num_comments": 11,
          "send_replies": true,
          "whitelist_status": "all_ads",
          "contest_mode": false,
          "mod_reports": [],
          "author_patreon_flair": false,
          "author_flair_text_color": null,
          "permalink": "/r/haskell/comments/oku7sn/installed_haskellstack_using_brew_and_vs_code/",
          "parent_whitelist_status": "all_ads",
          "stickied": false,
          "url": "https://www.reddit.com/r/haskell/comments/oku7sn/installed_haskellstack_using_brew_and_vs_code/",
          "subreddit_subscribers": 64950,
          "created_utc": 1626360114,
          "num_crossposts": 0,
          "media": null,
          "is_video": false
        }
      },
      {
        "kind": "t3",
        "data": {
          "approved_at_utc": null,
          "subreddit": "haskell",
          "selftext": "",
          "author_fullname": "t2_kmn6s",
          "saved": false,
          "mod_reason_title": null,
          "gilded": 0,
          "clicked": false,
          "title": "Type Theory Forall Podcast Episode #10 - Classical Logic vs Intuitionistic Logic, feat. Thorsten Altenkirch and Anupam Das",
          "link_flair_richtext": [],
          "subreddit_name_prefixed": "r/haskell",
          "hidden": false,
          "pwls": 6,
          "link_flair_css_class": null,
          "downs": 0,
          "top_awarded_type": null,
          "hide_score": false,
          "name": "t3_okc87x",
          "quarantine": false,
          "link_flair_text_color": "dark",
          "upvote_ratio": 0.96,
          "author_flair_background_color": null,
          "subreddit_type": "public",
          "ups": 48,
          "total_awards_received": 2,
          "media_embed": {},
          "author_flair_template_id": null,
          "is_original_content": false,
          "user_reports": [],
          "secure_media": null,
          "is_reddit_media_domain": false,
          "is_meta": false,
          "category": null,
          "secure_media_embed": {},
          "link_flair_text": null,
          "can_mod_post": false,
          "score": 48,
          "approved_by": null,
          "is_created_from_ads_ui": false,
          "author_premium": false,
          "thumbnail": "",
          "edited": false,
          "author_flair_css_class": null,
          "author_flair_richtext": [],
          "gildings": {},
          "content_categories": null,
          "is_self": false,
          "mod_note": null,
          "created": 1626321353,
          "link_flair_type": "text",
          "wls": 6,
          "removed_by_category": null,
          "banned_by": null,
          "author_flair_type": "text",
          "domain": "typetheoryforall.com",
          "allow_live_comments": false,
          "selftext_html": null,
          "likes": null,
          "suggested_sort": null,
          "banned_at_utc": null,
          "url_overridden_by_dest": "https://www.typetheoryforall.com/",
          "view_count": null,
          "archived": false,
          "no_follow": false,
          "is_crosspostable": false,
          "pinned": false,
          "over_18": false,
          "all_awardings": [
            {
              "giver_coin_reward": null,
              "subreddit_id": null,
              "is_new": false,
              "days_of_drip_extension": 0,
              "coin_price": 150,
              "id": "award_f44611f1-b89e-46dc-97fe-892280b13b82",
              "penny_donate": null,
              "award_sub_type": "GLOBAL",
              "coin_reward": 0,
              "icon_url": "https://i.redd.it/award_images/t5_22cerq/klvxk1wggfd41_Helpful.png",
              "days_of_premium": 0,
              "tiers_by_required_awardings": null,
              "resized_icons": [
                {
                  "url": "https://preview.redd.it/award_images/t5_22cerq/klvxk1wggfd41_Helpful.png?width=16&amp;height=16&amp;auto=webp&amp;s=a5662dfbdb402bf67866c050aa76c31c147c2f45",
                  "width": 16,
                  "height": 16
                },
                {
                  "url": "https://preview.redd.it/award_images/t5_22cerq/klvxk1wggfd41_Helpful.png?width=32&amp;height=32&amp;auto=webp&amp;s=a6882eb3f380e8e88009789f4d0072e17b8c59f1",
                  "width": 32,
                  "height": 32
                },
                {
                  "url": "https://preview.redd.it/award_images/t5_22cerq/klvxk1wggfd41_Helpful.png?width=48&amp;height=48&amp;auto=webp&amp;s=e50064b090879e8a0b55e433f6ee61d5cb5fbe1d",
                  "width": 48,
                  "height": 48
                },
                {
                  "url": "https://preview.redd.it/award_images/t5_22cerq/klvxk1wggfd41_Helpful.png?width=64&amp;height=64&amp;auto=webp&amp;s=8e5bb2e76683cb6b161830bcdd9642049d6adc11",
                  "width": 64,
                  "height": 64
                },
                {
                  "url": "https://preview.redd.it/award_images/t5_22cerq/klvxk1wggfd41_Helpful.png?width=128&amp;height=128&amp;auto=webp&amp;s=eda4a9246f95f42ee6940cc0ec65306fd20de878",
                  "width": 128,
                  "height": 128
                }
              ],
              "icon_width": 2048,
              "static_icon_width": 2048,
              "start_date": null,
              "is_enabled": true,
              "awardings_required_to_grant_benefits": null,
              "description": "Thank you stranger. Shows the award.",
              "end_date": null,
              "subreddit_coin_reward": 0,
              "count": 1,
              "static_icon_height": 2048,
              "name": "Helpful",
              "resized_static_icons": [
                {
                  "url": "https://preview.redd.it/award_images/t5_22cerq/klvxk1wggfd41_Helpful.png?width=16&amp;height=16&amp;auto=webp&amp;s=a5662dfbdb402bf67866c050aa76c31c147c2f45",
                  "width": 16,
                  "height": 16
                },
                {
                  "url": "https://preview.redd.it/award_images/t5_22cerq/klvxk1wggfd41_Helpful.png?width=32&amp;height=32&amp;auto=webp&amp;s=a6882eb3f380e8e88009789f4d0072e17b8c59f1",
                  "width": 32,
                  "height": 32
                },
                {
                  "url": "https://preview.redd.it/award_images/t5_22cerq/klvxk1wggfd41_Helpful.png?width=48&amp;height=48&amp;auto=webp&amp;s=e50064b090879e8a0b55e433f6ee61d5cb5fbe1d",
                  "width": 48,
                  "height": 48
                },
                {
                  "url": "https://preview.redd.it/award_images/t5_22cerq/klvxk1wggfd41_Helpful.png?width=64&amp;height=64&amp;auto=webp&amp;s=8e5bb2e76683cb6b161830bcdd9642049d6adc11",
                  "width": 64,
                  "height": 64
                },
                {
                  "url": "https://preview.redd.it/award_images/t5_22cerq/klvxk1wggfd41_Helpful.png?width=128&amp;height=128&amp;auto=webp&amp;s=eda4a9246f95f42ee6940cc0ec65306fd20de878",
                  "width": 128,
                  "height": 128
                }
              ],
              "icon_format": null,
              "icon_height": 2048,
              "penny_price": null,
              "award_type": "global",
              "static_icon_url": "https://i.redd.it/award_images/t5_22cerq/klvxk1wggfd41_Helpful.png"
            },
            {
              "giver_coin_reward": 0,
              "subreddit_id": null,
              "is_new": false,
              "days_of_drip_extension": 0,
              "coin_price": 80,
              "id": "award_8352bdff-3e03-4189-8a08-82501dd8f835",
              "penny_donate": 0,
              "award_sub_type": "GLOBAL",
              "coin_reward": 0,
              "icon_url": "https://i.redd.it/award_images/t5_q0gj4/ks45ij6w05f61_oldHugz.png",
              "days_of_premium": 0,
              "tiers_by_required_awardings": null,
              "resized_icons": [
                {
                  "url": "https://preview.redd.it/award_images/t5_q0gj4/ks45ij6w05f61_oldHugz.png?width=16&amp;height=16&amp;auto=webp&amp;s=73a23bf7f08b633508dedf457f2704c522b94a04",
                  "width": 16,
                  "height": 16
                },
                {
                  "url": "https://preview.redd.it/award_images/t5_q0gj4/ks45ij6w05f61_oldHugz.png?width=32&amp;height=32&amp;auto=webp&amp;s=50f2f16e71d2929e3d7275060af3ad6b851dbfb1",
                  "width": 32,
                  "height": 32
                },
                {
                  "url": "https://preview.redd.it/award_images/t5_q0gj4/ks45ij6w05f61_oldHugz.png?width=48&amp;height=48&amp;auto=webp&amp;s=ca487311563425e195699a4d7e4c57a98cbfde8b",
                  "width": 48,
                  "height": 48
                },
                {
                  "url": "https://preview.redd.it/award_images/t5_q0gj4/ks45ij6w05f61_oldHugz.png?width=64&amp;height=64&amp;auto=webp&amp;s=7b4eedcffb1c09a826e7837532c52979760f1d2b",
                  "width": 64,
                  "height": 64
                },
                {
                  "url": "https://preview.redd.it/award_images/t5_q0gj4/ks45ij6w05f61_oldHugz.png?width=128&amp;height=128&amp;auto=webp&amp;s=e4d5ab237eb71a9f02bb3bf9ad5ee43741918d6c",
                  "width": 128,
                  "height": 128
                }
              ],
              "icon_width": 2048,
              "static_icon_width": 2048,
              "start_date": null,
              "is_enabled": true,
              "awardings_required_to_grant_benefits": null,
              "description": "Everything is better with a good hug",
              "end_date": null,
              "subreddit_coin_reward": 0,
              "count": 1,
              "static_icon_height": 2048,
              "name": "Hugz",
              "resized_static_icons": [
                {
                  "url": "https://preview.redd.it/award_images/t5_q0gj4/fpm0r5ryq1361_PolarHugs.png?width=16&amp;height=16&amp;auto=webp&amp;s=69997ace3ef4ffc099b81d774c2c8f1530602875",
                  "width": 16,
                  "height": 16
                },
                {
                  "url": "https://preview.redd.it/award_images/t5_q0gj4/fpm0r5ryq1361_PolarHugs.png?width=32&amp;height=32&amp;auto=webp&amp;s=e9519d1999ef9dce5c8a9f59369cb92f52d95319",
                  "width": 32,
                  "height": 32
                },
                {
                  "url": "https://preview.redd.it/award_images/t5_q0gj4/fpm0r5ryq1361_PolarHugs.png?width=48&amp;height=48&amp;auto=webp&amp;s=f076c6434fb2d2f9075991810fd845c40fa73fc6",
                  "width": 48,
                  "height": 48
                },
                {
                  "url": "https://preview.redd.it/award_images/t5_q0gj4/fpm0r5ryq1361_PolarHugs.png?width=64&amp;height=64&amp;auto=webp&amp;s=85527145e0c4b754306a30df29e584fd16187636",
                  "width": 64,
                  "height": 64
                },
                {
                  "url": "https://preview.redd.it/award_images/t5_q0gj4/fpm0r5ryq1361_PolarHugs.png?width=128&amp;height=128&amp;auto=webp&amp;s=b8843cdf82c3b741d7af057c14076dcd2621e811",
                  "width": 128,
                  "height": 128
                }
              ],
              "icon_format": "PNG",
              "icon_height": 2048,
              "penny_price": 0,
              "award_type": "global",
              "static_icon_url": "https://i.redd.it/award_images/t5_q0gj4/fpm0r5ryq1361_PolarHugs.png"
            }
          ],
          "awarders": [],
          "media_only": false,
          "can_gild": false,
          "spoiler": false,
          "locked": false,
          "author_flair_text": null,
          "treatment_tags": [],
          "visited": false,
          "removed_by": null,
          "num_reports": null,
          "distinguished": null,
          "subreddit_id": "t5_2qh36",
          "mod_reason_by": null,
          "removal_reason": null,
          "link_flair_background_color": "",
          "id": "okc87x",
          "is_robot_indexable": true,
          "report_reasons": null,
          "author": "pedroabreu",
          "discussion_type": null,
          "num_comments": 4,
          "send_replies": true,
          "whitelist_status": "all_ads",
          "contest_mode": false,
          "mod_reports": [],
          "author_patreon_flair": false,
          "author_flair_text_color": null,
          "permalink": "/r/haskell/comments/okc87x/type_theory_forall_podcast_episode_10_classical/",
          "parent_whitelist_status": "all_ads",
          "stickied": false,
          "url": "https://www.typetheoryforall.com/",
          "subreddit_subscribers": 64950,
          "created_utc": 1626292553,
          "num_crossposts": 0,
          "media": null,
          "is_video": false
        }
      },
      {
        "kind": "t3",
        "data": {
          "approved_at_utc": null,
          "subreddit": "haskell",
          "selftext": "",
          "author_fullname": "t2_67ep9",
          "saved": false,
          "mod_reason_title": null,
          "gilded": 0,
          "clicked": false,
          "title": "Artyom Kuznetsov - GHC: Dependency Analysis of Haskell Declarations",
          "link_flair_richtext": [],
          "subreddit_name_prefixed": "r/haskell",
          "hidden": false,
          "pwls": 6,
          "link_flair_css_class": null,
          "downs": 0,
          "top_awarded_type": null,
          "hide_score": false,
          "name": "t3_ok2p0b",
          "quarantine": false,
          "link_flair_text_color": "dark",
          "upvote_ratio": 0.98,
          "author_flair_background_color": null,
          "subreddit_type": "public",
          "ups": 29,
          "total_awards_received": 0,
          "media_embed": {
            "content": "&lt;iframe width=\"356\" height=\"200\" src=\"https://www.youtube.com/embed/XspZEqNl6Wo?feature=oembed&amp;enablejsapi=1\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen&gt;&lt;/iframe&gt;",
            "width": 356,
            "scrolling": false,
            "height": 200
          },
          "author_flair_template_id": null,
          "is_original_content": false,
          "user_reports": [],
          "secure_media": {
            "type": "youtube.com",
            "oembed": {
              "provider_url": "https://www.youtube.com/",
              "version": "1.0",
              "title": "Artyom Kuznetsov - GHC: Dependency Analysis of Haskell Declarations",
              "type": "video",
              "thumbnail_width": 480,
              "height": 200,
              "width": 356,
              "html": "&lt;iframe width=\"356\" height=\"200\" src=\"https://www.youtube.com/embed/XspZEqNl6Wo?feature=oembed&amp;enablejsapi=1\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen&gt;&lt;/iframe&gt;",
              "author_name": "ZÃ¼rich Friends of Haskell",
              "provider_name": "YouTube",
              "thumbnail_url": "https://i.ytimg.com/vi/XspZEqNl6Wo/hqdefault.jpg",
              "thumbnail_height": 360,
              "author_url": "https://www.youtube.com/channel/UC2zfPMH_srjxUN5EYrfIhCw"
            }
          },
          "is_reddit_media_domain": false,
          "is_meta": false,
          "category": null,
          "secure_media_embed": {
            "content": "&lt;iframe width=\"356\" height=\"200\" src=\"https://www.youtube.com/embed/XspZEqNl6Wo?feature=oembed&amp;enablejsapi=1\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen&gt;&lt;/iframe&gt;",
            "width": 356,
            "scrolling": false,
            "media_domain_url": "https://www.redditmedia.com/mediaembed/ok2p0b",
            "height": 200
          },
          "link_flair_text": null,
          "can_mod_post": false,
          "score": 29,
          "approved_by": null,
          "is_created_from_ads_ui": false,
          "author_premium": false,
          "thumbnail": "",
          "edited": false,
          "author_flair_css_class": null,
          "author_flair_richtext": [],
          "gildings": {},
          "content_categories": null,
          "is_self": false,
          "mod_note": null,
          "created": 1626292118,
          "link_flair_type": "text",
          "wls": 6,
          "removed_by_category": null,
          "banned_by": null,
          "author_flair_type": "text",
          "domain": "youtu.be",
          "allow_live_comments": false,
          "selftext_html": null,
          "likes": null,
          "suggested_sort": null,
          "banned_at_utc": null,
          "url_overridden_by_dest": "https://youtu.be/XspZEqNl6Wo",
          "view_count": null,
          "archived": false,
          "no_follow": false,
          "is_crosspostable": false,
          "pinned": false,
          "over_18": false,
          "all_awardings": [],
          "awarders": [],
          "media_only": false,
          "can_gild": false,
          "spoiler": false,
          "locked": false,
          "author_flair_text": null,
          "treatment_tags": [],
          "visited": false,
          "removed_by": null,
          "num_reports": null,
          "distinguished": null,
          "subreddit_id": "t5_2qh36",
          "mod_reason_by": null,
          "removal_reason": null,
          "link_flair_background_color": "",
          "id": "ok2p0b",
          "is_robot_indexable": true,
          "report_reasons": null,
          "author": "instantdoctor",
          "discussion_type": null,
          "num_comments": 0,
          "send_replies": false,
          "whitelist_status": "all_ads",
          "contest_mode": false,
          "mod_reports": [],
          "author_patreon_flair": false,
          "author_flair_text_color": null,
          "permalink": "/r/haskell/comments/ok2p0b/artyom_kuznetsov_ghc_dependency_analysis_of/",
          "parent_whitelist_status": "all_ads",
          "stickied": false,
          "url": "https://youtu.be/XspZEqNl6Wo",
          "subreddit_subscribers": 64950,
          "created_utc": 1626263318,
          "num_crossposts": 0,
          "media": {
            "type": "youtube.com",
            "oembed": {
              "provider_url": "https://www.youtube.com/",
              "version": "1.0",
              "title": "Artyom Kuznetsov - GHC: Dependency Analysis of Haskell Declarations",
              "type": "video",
              "thumbnail_width": 480,
              "height": 200,
              "width": 356,
              "html": "&lt;iframe width=\"356\" height=\"200\" src=\"https://www.youtube.com/embed/XspZEqNl6Wo?feature=oembed&amp;enablejsapi=1\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen&gt;&lt;/iframe&gt;",
              "author_name": "ZÃ¼rich Friends of Haskell",
              "provider_name": "YouTube",
              "thumbnail_url": "https://i.ytimg.com/vi/XspZEqNl6Wo/hqdefault.jpg",
              "thumbnail_height": 360,
              "author_url": "https://www.youtube.com/channel/UC2zfPMH_srjxUN5EYrfIhCw"
            }
          },
          "is_video": false
        }
      },
      {
        "kind": "t3",
        "data": {
          "approved_at_utc": null,
          "subreddit": "haskell",
          "selftext": "",
          "author_fullname": "t2_2j1hpdsi",
          "saved": false,
          "mod_reason_title": null,
          "gilded": 0,
          "clicked": false,
          "title": "The power of fundamental abstractions",
          "link_flair_richtext": [],
          "subreddit_name_prefixed": "r/haskell",
          "hidden": false,
          "pwls": 6,
          "link_flair_css_class": null,
          "downs": 0,
          "top_awarded_type": null,
          "hide_score": false,
          "name": "t3_ok0uw2",
          "quarantine": false,
          "link_flair_text_color": "dark",
          "upvote_ratio": 1,
          "author_flair_background_color": null,
          "subreddit_type": "public",
          "ups": 22,
          "total_awards_received": 0,
          "media_embed": {
            "content": "&lt;iframe width=\"356\" height=\"200\" src=\"https://www.youtube.com/embed/tlXz3aKJ6mI?feature=oembed&amp;enablejsapi=1\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen&gt;&lt;/iframe&gt;",
            "width": 356,
            "scrolling": false,
            "height": 200
          },
          "author_flair_template_id": null,
          "is_original_content": false,
          "user_reports": [],
          "secure_media": {
            "type": "youtube.com",
            "oembed": {
              "provider_url": "https://www.youtube.com/",
              "version": "1.0",
              "title": "The Power of Fundamental Abstractions  - Jan van BrÃ¼gge - TechWeeklies",
              "type": "video",
              "thumbnail_width": 480,
              "height": 200,
              "width": 356,
              "html": "&lt;iframe width=\"356\" height=\"200\" src=\"https://www.youtube.com/embed/tlXz3aKJ6mI?feature=oembed&amp;enablejsapi=1\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen&gt;&lt;/iframe&gt;",
              "author_name": "Futurice",
              "provider_name": "YouTube",
              "thumbnail_url": "https://i.ytimg.com/vi/tlXz3aKJ6mI/hqdefault.jpg",
              "thumbnail_height": 360,
              "author_url": "https://www.youtube.com/c/Futurice-Official"
            }
          },
          "is_reddit_media_domain": false,
          "is_meta": false,
          "category": null,
          "secure_media_embed": {
            "content": "&lt;iframe width=\"356\" height=\"200\" src=\"https://www.youtube.com/embed/tlXz3aKJ6mI?feature=oembed&amp;enablejsapi=1\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen&gt;&lt;/iframe&gt;",
            "width": 356,
            "scrolling": false,
            "media_domain_url": "https://www.redditmedia.com/mediaembed/ok0uw2",
            "height": 200
          },
          "link_flair_text": null,
          "can_mod_post": false,
          "score": 22,
          "approved_by": null,
          "is_created_from_ads_ui": false,
          "author_premium": false,
          "thumbnail": "",
          "edited": false,
          "author_flair_css_class": null,
          "author_flair_richtext": [],
          "gildings": {},
          "content_categories": null,
          "is_self": false,
          "mod_note": null,
          "created": 1626284140,
          "link_flair_type": "text",
          "wls": 6,
          "removed_by_category": null,
          "banned_by": null,
          "author_flair_type": "text",
          "domain": "youtu.be",
          "allow_live_comments": false,
          "selftext_html": null,
          "likes": null,
          "suggested_sort": null,
          "banned_at_utc": null,
          "url_overridden_by_dest": "https://youtu.be/tlXz3aKJ6mI",
          "view_count": null,
          "archived": false,
          "no_follow": false,
          "is_crosspostable": false,
          "pinned": false,
          "over_18": false,
          "all_awardings": [],
          "awarders": [],
          "media_only": false,
          "can_gild": false,
          "spoiler": false,
          "locked": false,
          "author_flair_text": null,
          "treatment_tags": [],
          "visited": false,
          "removed_by": null,
          "num_reports": null,
          "distinguished": null,
          "subreddit_id": "t5_2qh36",
          "mod_reason_by": null,
          "removal_reason": null,
          "link_flair_background_color": "",
          "id": "ok0uw2",
          "is_robot_indexable": true,
          "report_reasons": null,
          "author": "jvanbruegge",
          "discussion_type": null,
          "num_comments": 2,
          "send_replies": true,
          "whitelist_status": "all_ads",
          "contest_mode": false,
          "mod_reports": [],
          "author_patreon_flair": false,
          "author_flair_text_color": null,
          "permalink": "/r/haskell/comments/ok0uw2/the_power_of_fundamental_abstractions/",
          "parent_whitelist_status": "all_ads",
          "stickied": false,
          "url": "https://youtu.be/tlXz3aKJ6mI",
          "subreddit_subscribers": 64950,
          "created_utc": 1626255340,
          "num_crossposts": 0,
          "media": {
            "type": "youtube.com",
            "oembed": {
              "provider_url": "https://www.youtube.com/",
              "version": "1.0",
              "title": "The Power of Fundamental Abstractions  - Jan van BrÃ¼gge - TechWeeklies",
              "type": "video",
              "thumbnail_width": 480,
              "height": 200,
              "width": 356,
              "html": "&lt;iframe width=\"356\" height=\"200\" src=\"https://www.youtube.com/embed/tlXz3aKJ6mI?feature=oembed&amp;enablejsapi=1\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen&gt;&lt;/iframe&gt;",
              "author_name": "Futurice",
              "provider_name": "YouTube",
              "thumbnail_url": "https://i.ytimg.com/vi/tlXz3aKJ6mI/hqdefault.jpg",
              "thumbnail_height": 360,
              "author_url": "https://www.youtube.com/c/Futurice-Official"
            }
          },
          "is_video": false
        }
      },
      {
        "kind": "t3",
        "data": {
          "approved_at_utc": null,
          "subreddit": "haskell",
          "selftext": "",
          "author_fullname": "t2_4hurx",
          "saved": false,
          "mod_reason_title": null,
          "gilded": 0,
          "clicked": false,
          "title": "Cast Haskell values with Witch",
          "link_flair_richtext": [],
          "subreddit_name_prefixed": "r/haskell",
          "hidden": false,
          "pwls": 6,
          "link_flair_css_class": "",
          "downs": 0,
          "top_awarded_type": null,
          "hide_score": false,
          "name": "t3_oje9k9",
          "quarantine": false,
          "link_flair_text_color": "light",
          "upvote_ratio": 1,
          "author_flair_background_color": null,
          "subreddit_type": "public",
          "ups": 103,
          "total_awards_received": 0,
          "media_embed": {},
          "author_flair_template_id": null,
          "is_original_content": true,
          "user_reports": [],
          "secure_media": null,
          "is_reddit_media_domain": false,
          "is_meta": false,
          "category": null,
          "secure_media_embed": {},
          "link_flair_text": "announcement",
          "can_mod_post": false,
          "score": 103,
          "approved_by": null,
          "is_created_from_ads_ui": false,
          "author_premium": false,
          "thumbnail": "",
          "edited": false,
          "author_flair_css_class": null,
          "author_flair_richtext": [],
          "gildings": {},
          "content_categories": null,
          "is_self": false,
          "mod_note": null,
          "created": 1626207047,
          "link_flair_type": "text",
          "wls": 6,
          "removed_by_category": null,
          "banned_by": null,
          "author_flair_type": "text",
          "domain": "taylor.fausak.me",
          "allow_live_comments": false,
          "selftext_html": null,
          "likes": null,
          "suggested_sort": null,
          "banned_at_utc": null,
          "url_overridden_by_dest": "https://taylor.fausak.me/2021/07/13/witch/",
          "view_count": null,
          "archived": false,
          "no_follow": false,
          "is_crosspostable": false,
          "pinned": false,
          "over_18": false,
          "all_awardings": [],
          "awarders": [],
          "media_only": false,
          "link_flair_template_id": "fd84a740-e679-11e8-ae50-0eda5d02591a",
          "can_gild": false,
          "spoiler": false,
          "locked": false,
          "author_flair_text": null,
          "treatment_tags": [],
          "visited": false,
          "removed_by": null,
          "num_reports": null,
          "distinguished": null,
          "subreddit_id": "t5_2qh36",
          "mod_reason_by": null,
          "removal_reason": null,
          "link_flair_background_color": "#646d73",
          "id": "oje9k9",
          "is_robot_indexable": true,
          "report_reasons": null,
          "author": "taylorfausak",
          "discussion_type": null,
          "num_comments": 20,
          "send_replies": true,
          "whitelist_status": "all_ads",
          "contest_mode": false,
          "mod_reports": [],
          "author_patreon_flair": false,
          "author_flair_text_color": null,
          "permalink": "/r/haskell/comments/oje9k9/cast_haskell_values_with_witch/",
          "parent_whitelist_status": "all_ads",
          "stickied": false,
          "url": "https://taylor.fausak.me/2021/07/13/witch/",
          "subreddit_subscribers": 64950,
          "created_utc": 1626178247,
          "num_crossposts": 0,
          "media": null,
          "is_video": false
        }
      },
      {
        "kind": "t3",
        "data": {
          "approved_at_utc": null,
          "subreddit": "haskell",
          "selftext": "\n\n[View Poll](https://www.reddit.com/poll/ok7f57)",
          "author_fullname": "t2_6nmyj2y2",
          "saved": false,
          "mod_reason_title": null,
          "gilded": 0,
          "clicked": false,
          "title": "Which is the most used term for Haskell programmers?",
          "link_flair_richtext": [],
          "subreddit_name_prefixed": "r/haskell",
          "hidden": false,
          "pwls": 6,
          "link_flair_css_class": null,
          "downs": 0,
          "top_awarded_type": null,
          "hide_score": false,
          "name": "t3_ok7f57",
          "quarantine": false,
          "link_flair_text_color": "dark",
          "upvote_ratio": 0.36,
          "author_flair_background_color": null,
          "subreddit_type": "public",
          "ups": 0,
          "total_awards_received": 0,
          "media_embed": {},
          "author_flair_template_id": null,
          "is_original_content": false,
          "user_reports": [],
          "secure_media": null,
          "is_reddit_media_domain": false,
          "is_meta": false,
          "category": null,
          "secure_media_embed": {},
          "link_flair_text": null,
          "can_mod_post": false,
          "score": 0,
          "approved_by": null,
          "is_created_from_ads_ui": false,
          "author_premium": false,
          "thumbnail": "",
          "edited": false,
          "author_flair_css_class": null,
          "author_flair_richtext": [],
          "gildings": {},
          "content_categories": null,
          "is_self": true,
          "mod_note": null,
          "created": 1626307385,
          "link_flair_type": "text",
          "wls": 6,
          "removed_by_category": null,
          "banned_by": null,
          "author_flair_type": "text",
          "domain": "self.haskell",
          "allow_live_comments": false,
          "selftext_html": "&lt;!-- SC_OFF --&gt;&lt;div class=\"md\"&gt;&lt;p&gt;&lt;a href=\"https://www.reddit.com/poll/ok7f57\"&gt;View Poll&lt;/a&gt;&lt;/p&gt;\n&lt;/div&gt;&lt;!-- SC_ON --&gt;",
          "likes": null,
          "suggested_sort": null,
          "banned_at_utc": null,
          "view_count": null,
          "archived": false,
          "no_follow": true,
          "is_crosspostable": false,
          "pinned": false,
          "over_18": false,
          "all_awardings": [],
          "awarders": [],
          "media_only": false,
          "can_gild": false,
          "spoiler": false,
          "locked": false,
          "author_flair_text": null,
          "treatment_tags": [],
          "visited": false,
          "removed_by": null,
          "num_reports": null,
          "distinguished": null,
          "subreddit_id": "t5_2qh36",
          "mod_reason_by": null,
          "removal_reason": null,
          "link_flair_background_color": "",
          "id": "ok7f57",
          "is_robot_indexable": true,
          "report_reasons": null,
          "author": "Microtribute",
          "discussion_type": null,
          "num_comments": 12,
          "send_replies": true,
          "whitelist_status": "all_ads",
          "contest_mode": false,
          "poll_data": {
            "prediction_status": null,
            "tournament_id": null,
            "voting_end_timestamp": 1626537785266,
            "options": [
              {
                "text": "Haskellite",
                "vote_count": 9,
                "id": "9130610"
              },
              {
                "text": "Haskeller",
                "vote_count": 298,
                "id": "9130611"
              },
              {
                "text": "Haskellist",
                "vote_count": 12,
                "id": "9130612"
              },
              {
                "text": "Other (Please Comment)",
                "vote_count": 18,
                "id": "9130613"
              }
            ],
            "user_selection": null,
            "is_prediction": false,
            "resolved_option_id": null,
            "user_won_amount": null,
            "total_vote_count": 337,
            "total_stake_amount": null
          },
          "author_patreon_flair": false,
          "author_flair_text_color": null,
          "permalink": "/r/haskell/comments/ok7f57/which_is_the_most_used_term_for_haskell/",
          "parent_whitelist_status": "all_ads",
          "stickied": false,
          "mod_reports": [],
          "url": "https://www.reddit.com/r/haskell/comments/ok7f57/which_is_the_most_used_term_for_haskell/",
          "subreddit_subscribers": 64950,
          "created_utc": 1626278585,
          "num_crossposts": 0,
          "media": null,
          "is_video": false
        }
      },
      {
        "kind": "t3",
        "data": {
          "approved_at_utc": null,
          "subreddit": "haskell",
          "selftext": "Code is here:\n\n* [gist](https://gist.github.com/Icelandjack/63bd76d06c265d39ffdce46293d6d67c)\n\nI recently made a post about [deriving GADTs with DerivingVia](https://www.reddit.com/r/haskell/comments/og9oou/derivingvia_gadts/) and it got me thinking if I could implement generic definitions without so much boilerplate. The standard way of defining such a generic instance with [`GHC.Generics`](https://hackage.haskell.org/package/base-4.15.0.0/docs/GHC-Generics.html) is to define a type class\n\n    class GBinaryPut f where\n      gput :: f t -&gt; Put\n\nwith an instance for each of the polynomial functor building blocks\n\n    instance GBinaryPut V1 where gput _ = pure ()\n    instance GBinaryPut U1 where gput U1 = pure ()\n    instance (GBinaryPut a, GBinaryPut b) =&gt; GBinaryPut (a :*: b) where gput (x :*: y) = gput x &lt;&gt; gput y\n    instance GBinaryPut a =&gt; GBinaryPut (M1 i c a) where gput = gput . unM1\n    instance Binary a =&gt; GBinaryPut (K1 i a) where gput = put . unK1\n\nSo I thought if there was a nicer way of writing this. [*generics-sop*](https://hackage.haskell.org/package/generics-sop) already has a nice interface for writing such functions but I wanted something that could work on top of functor based libraries like `GHC.Generics` and [*kind-generics*](https://hackage.haskell.org/package/kind-generics).\n\nTo that end I defined pattern synonyms on top of the [`Type.Reflection` module](https://hackage.haskell.org/package/base-4.15.0.0/docs/Type-Reflection.html) (where `TypeRep` is the same as `Sing` from the [*singletons* library](https://hackage.haskell.org/package/singletons))\n\n    pattern IsU1   :: ..\n    pattern IsV1   :: ..\n    pattern IsK1   :: ..\n    pattern IsM1   :: ..\n    pattern IsProd :: ..\n    pattern IsSum  :: ..\n\nthat can be used to branch on the functors as such\n\n    gput :: AllCls Binary rep =&gt; TypeRep rep -&gt; rep () -&gt; Put\n    gput IsV1         _           = mempty\n    gput IsU1         _           = mempty\n    gput IsK1         (K1 a)      = put a\n    gput (IsM1 f)     (M1 as)     = gput f as\n    gput (IsProd f g) (as :*: bs) = gput f as &lt;&gt; gput g bs\n\nwhich gives us a generic instance we can derive via\n\n    instance (AllCls Binary (Rep a), Typeable (Rep a), Generic a) =&gt; Binary (Generically a) where\n      put :: Generically a -&gt; Put\n      put (Generically a) = gput typeRep (from a)\n\nThis is something I came up with yesterday, it's a rough first draft and as such it doesn't do any exhaustivity checking (but it isn't hard since we have the singleton already). Using `gmappend` on a sum type fails at runtime but I think it looks clearer than defining a typeclass and will hopefully inspire others to define a more sophisticated solution.\n\n    gmappend :: AllCls Semigroup rep =&gt; TypeRep rep -&gt; rep () -&gt; rep () -&gt; rep ()\n    gmappend IsK1         (K1 a)      (K1 b)      = K1 (a &lt;&gt; b)\n    gmappend (IsM1 f)     (M1 as)     (M1 bs)     = M1 (gmappend f as bs)\n    gmappend (IsProd f g) (as1:*:bs1) (as2:*:bs2) = gmappend f as1 as2 :*: gmappend g bs1 bs2\n\nIt would be great to release this as a library or add it to `GHC.Generics`.",
          "author_fullname": "t2_3qjdu",
          "saved": false,
          "mod_reason_title": null,
          "gilded": 0,
          "clicked": false,
          "title": "Classless GHC.Generic with Type.Reflection",
          "link_flair_richtext": [],
          "subreddit_name_prefixed": "r/haskell",
          "hidden": false,
          "pwls": 6,
          "link_flair_css_class": null,
          "downs": 0,
          "top_awarded_type": null,
          "hide_score": false,
          "name": "t3_ojlutn",
          "quarantine": false,
          "link_flair_text_color": "dark",
          "upvote_ratio": 1,
          "author_flair_background_color": null,
          "subreddit_type": "public",
          "ups": 13,
          "total_awards_received": 0,
          "media_embed": {},
          "author_flair_template_id": null,
          "is_original_content": false,
          "user_reports": [],
          "secure_media": null,
          "is_reddit_media_domain": false,
          "is_meta": false,
          "category": null,
          "secure_media_embed": {},
          "link_flair_text": null,
          "can_mod_post": false,
          "score": 13,
          "approved_by": null,
          "is_created_from_ads_ui": false,
          "author_premium": false,
          "thumbnail": "",
          "edited": 1626201881,
          "author_flair_css_class": null,
          "author_flair_richtext": [],
          "gildings": {},
          "content_categories": null,
          "is_self": true,
          "mod_note": null,
          "created": 1626230148,
          "link_flair_type": "text",
          "wls": 6,
          "removed_by_category": null,
          "banned_by": null,
          "author_flair_type": "text",
          "domain": "self.haskell",
          "allow_live_comments": false,
          "selftext_html": "&lt;!-- SC_OFF --&gt;&lt;div class=\"md\"&gt;&lt;p&gt;Code is here:&lt;/p&gt;\n\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\"https://gist.github.com/Icelandjack/63bd76d06c265d39ffdce46293d6d67c\"&gt;gist&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n\n&lt;p&gt;I recently made a post about &lt;a href=\"https://www.reddit.com/r/haskell/comments/og9oou/derivingvia_gadts/\"&gt;deriving GADTs with DerivingVia&lt;/a&gt; and it got me thinking if I could implement generic definitions without so much boilerplate. The standard way of defining such a generic instance with &lt;a href=\"https://hackage.haskell.org/package/base-4.15.0.0/docs/GHC-Generics.html\"&gt;&lt;code&gt;GHC.Generics&lt;/code&gt;&lt;/a&gt; is to define a type class&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;class GBinaryPut f where\n  gput :: f t -&amp;gt; Put\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;with an instance for each of the polynomial functor building blocks&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;instance GBinaryPut V1 where gput _ = pure ()\ninstance GBinaryPut U1 where gput U1 = pure ()\ninstance (GBinaryPut a, GBinaryPut b) =&amp;gt; GBinaryPut (a :*: b) where gput (x :*: y) = gput x &amp;lt;&amp;gt; gput y\ninstance GBinaryPut a =&amp;gt; GBinaryPut (M1 i c a) where gput = gput . unM1\ninstance Binary a =&amp;gt; GBinaryPut (K1 i a) where gput = put . unK1\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;So I thought if there was a nicer way of writing this. &lt;a href=\"https://hackage.haskell.org/package/generics-sop\"&gt;&lt;em&gt;generics-sop&lt;/em&gt;&lt;/a&gt; already has a nice interface for writing such functions but I wanted something that could work on top of functor based libraries like &lt;code&gt;GHC.Generics&lt;/code&gt; and &lt;a href=\"https://hackage.haskell.org/package/kind-generics\"&gt;&lt;em&gt;kind-generics&lt;/em&gt;&lt;/a&gt;.&lt;/p&gt;\n\n&lt;p&gt;To that end I defined pattern synonyms on top of the &lt;a href=\"https://hackage.haskell.org/package/base-4.15.0.0/docs/Type-Reflection.html\"&gt;&lt;code&gt;Type.Reflection&lt;/code&gt; module&lt;/a&gt; (where &lt;code&gt;TypeRep&lt;/code&gt; is the same as &lt;code&gt;Sing&lt;/code&gt; from the &lt;a href=\"https://hackage.haskell.org/package/singletons\"&gt;&lt;em&gt;singletons&lt;/em&gt; library&lt;/a&gt;)&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;pattern IsU1   :: ..\npattern IsV1   :: ..\npattern IsK1   :: ..\npattern IsM1   :: ..\npattern IsProd :: ..\npattern IsSum  :: ..\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;that can be used to branch on the functors as such&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;gput :: AllCls Binary rep =&amp;gt; TypeRep rep -&amp;gt; rep () -&amp;gt; Put\ngput IsV1         _           = mempty\ngput IsU1         _           = mempty\ngput IsK1         (K1 a)      = put a\ngput (IsM1 f)     (M1 as)     = gput f as\ngput (IsProd f g) (as :*: bs) = gput f as &amp;lt;&amp;gt; gput g bs\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;which gives us a generic instance we can derive via&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;instance (AllCls Binary (Rep a), Typeable (Rep a), Generic a) =&amp;gt; Binary (Generically a) where\n  put :: Generically a -&amp;gt; Put\n  put (Generically a) = gput typeRep (from a)\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;This is something I came up with yesterday, it&amp;#39;s a rough first draft and as such it doesn&amp;#39;t do any exhaustivity checking (but it isn&amp;#39;t hard since we have the singleton already). Using &lt;code&gt;gmappend&lt;/code&gt; on a sum type fails at runtime but I think it looks clearer than defining a typeclass and will hopefully inspire others to define a more sophisticated solution.&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;gmappend :: AllCls Semigroup rep =&amp;gt; TypeRep rep -&amp;gt; rep () -&amp;gt; rep () -&amp;gt; rep ()\ngmappend IsK1         (K1 a)      (K1 b)      = K1 (a &amp;lt;&amp;gt; b)\ngmappend (IsM1 f)     (M1 as)     (M1 bs)     = M1 (gmappend f as bs)\ngmappend (IsProd f g) (as1:*:bs1) (as2:*:bs2) = gmappend f as1 as2 :*: gmappend g bs1 bs2\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;It would be great to release this as a library or add it to &lt;code&gt;GHC.Generics&lt;/code&gt;.&lt;/p&gt;\n&lt;/div&gt;&lt;!-- SC_ON --&gt;",
          "likes": null,
          "suggested_sort": null,
          "banned_at_utc": null,
          "view_count": null,
          "archived": false,
          "no_follow": false,
          "is_crosspostable": false,
          "pinned": false,
          "over_18": false,
          "all_awardings": [],
          "awarders": [],
          "media_only": false,
          "can_gild": false,
          "spoiler": false,
          "locked": false,
          "author_flair_text": null,
          "treatment_tags": [],
          "visited": false,
          "removed_by": null,
          "num_reports": null,
          "distinguished": null,
          "subreddit_id": "t5_2qh36",
          "mod_reason_by": null,
          "removal_reason": null,
          "link_flair_background_color": "",
          "id": "ojlutn",
          "is_robot_indexable": true,
          "report_reasons": null,
          "author": "Iceland_jack",
          "discussion_type": null,
          "num_comments": 13,
          "send_replies": true,
          "whitelist_status": "all_ads",
          "contest_mode": false,
          "mod_reports": [],
          "author_patreon_flair": false,
          "author_flair_text_color": null,
          "permalink": "/r/haskell/comments/ojlutn/classless_ghcgeneric_with_typereflection/",
          "parent_whitelist_status": "all_ads",
          "stickied": false,
          "url": "https://www.reddit.com/r/haskell/comments/ojlutn/classless_ghcgeneric_with_typereflection/",
          "subreddit_subscribers": 64950,
          "created_utc": 1626201348,
          "num_crossposts": 0,
          "media": null,
          "is_video": false
        }
      },
      {
        "kind": "t3",
        "data": {
          "approved_at_utc": null,
          "subreddit": "haskell",
          "selftext": "I have a college exam next week on haskell and I still only know the basics. Does anyone have any recommendations how to learn haskell fast?",
          "author_fullname": "t2_d6iq0vxh",
          "saved": false,
          "mod_reason_title": null,
          "gilded": 0,
          "clicked": false,
          "title": "Learn haskell",
          "link_flair_richtext": [],
          "subreddit_name_prefixed": "r/haskell",
          "hidden": false,
          "pwls": 6,
          "link_flair_css_class": "",
          "downs": 0,
          "top_awarded_type": null,
          "hide_score": false,
          "name": "t3_ojzpta",
          "quarantine": false,
          "link_flair_text_color": "light",
          "upvote_ratio": 0.53,
          "author_flair_background_color": null,
          "subreddit_type": "public",
          "ups": 1,
          "total_awards_received": 0,
          "media_embed": {},
          "author_flair_template_id": null,
          "is_original_content": false,
          "user_reports": [],
          "secure_media": null,
          "is_reddit_media_domain": false,
          "is_meta": false,
          "category": null,
          "secure_media_embed": {},
          "link_flair_text": "question",
          "can_mod_post": false,
          "score": 1,
          "approved_by": null,
          "is_created_from_ads_ui": false,
          "author_premium": false,
          "thumbnail": "",
          "edited": false,
          "author_flair_css_class": null,
          "author_flair_richtext": [],
          "gildings": {},
          "content_categories": null,
          "is_self": true,
          "mod_note": null,
          "created": 1626278602,
          "link_flair_type": "text",
          "wls": 6,
          "removed_by_category": null,
          "banned_by": null,
          "author_flair_type": "text",
          "domain": "self.haskell",
          "allow_live_comments": false,
          "selftext_html": "&lt;!-- SC_OFF --&gt;&lt;div class=\"md\"&gt;&lt;p&gt;I have a college exam next week on haskell and I still only know the basics. Does anyone have any recommendations how to learn haskell fast?&lt;/p&gt;\n&lt;/div&gt;&lt;!-- SC_ON --&gt;",
          "likes": null,
          "suggested_sort": null,
          "banned_at_utc": null,
          "view_count": null,
          "archived": false,
          "no_follow": true,
          "is_crosspostable": false,
          "pinned": false,
          "over_18": false,
          "all_awardings": [],
          "awarders": [],
          "media_only": false,
          "link_flair_template_id": "cceadda8-25af-11eb-ba66-0e76c7963e23",
          "can_gild": false,
          "spoiler": false,
          "locked": false,
          "author_flair_text": null,
          "treatment_tags": [],
          "visited": false,
          "removed_by": null,
          "num_reports": null,
          "distinguished": null,
          "subreddit_id": "t5_2qh36",
          "mod_reason_by": null,
          "removal_reason": null,
          "link_flair_background_color": "#646d73",
          "id": "ojzpta",
          "is_robot_indexable": true,
          "report_reasons": null,
          "author": "Uniqueeeeeeeeeeee",
          "discussion_type": null,
          "num_comments": 19,
          "send_replies": true,
          "whitelist_status": "all_ads",
          "contest_mode": false,
          "mod_reports": [],
          "author_patreon_flair": false,
          "author_flair_text_color": null,
          "permalink": "/r/haskell/comments/ojzpta/learn_haskell/",
          "parent_whitelist_status": "all_ads",
          "stickied": false,
          "url": "https://www.reddit.com/r/haskell/comments/ojzpta/learn_haskell/",
          "subreddit_subscribers": 64950,
          "created_utc": 1626249802,
          "num_crossposts": 0,
          "media": null,
          "is_video": false
        }
      },
      {
        "kind": "t3",
        "data": {
          "approved_at_utc": null,
          "subreddit": "haskell",
          "selftext": "Essentially, a friend of mine was like \"How do you even read a file in a purely functional language?\"\n\nSo I sat down with him and wrote a program that is essentially the `cat` tool without all the bloat like `--help` and stuff: take filename in, read the file, print it out. And that program literally takes two lines of Haskell code. It came out so concise without me even trying that I just had to share it with you.\n\n    import System.Environment (getArgs)\n    main = getArgs &gt;&gt;= (readFile . head) &gt;&gt;= putStrLn\n\nIt's actually just **one** line of useful code if you exclude the import statement. Show me a language that can do it more elegantly! I'll wait...\n\n **Update:** some people didn't like the fact that my 'cat' implementation doesn't support file concatenation and offered their implementations. I've come up with two that are also good-looking.\n\n    import System.Environment (getArgs)\n    import Control.Monad\n    main = getArgs &gt;&gt;= traverse (readFile &gt;=&gt; putStr)\n\nThis one requires Control.Monad, but looks slick. However, it can be avoided using some lambda magic:\n\n    import System.Environment (getArgs)\n    main = getArgs &gt;&gt;= traverse (\\file -&gt; readFile file &gt;&gt;= putStr)\n\nThis works exactly the same, but your linter will urge you to use `&gt;=&gt;` (you don't have to obey).",
          "author_fullname": "t2_2nbe2ghm",
          "saved": false,
          "mod_reason_title": null,
          "gilded": 0,
          "clicked": false,
          "title": "Smallest 'cat' utility (that's ever existed?)",
          "link_flair_richtext": [],
          "subreddit_name_prefixed": "r/haskell",
          "hidden": false,
          "pwls": 6,
          "link_flair_css_class": null,
          "downs": 0,
          "top_awarded_type": null,
          "hide_score": false,
          "name": "t3_ojk63k",
          "quarantine": false,
          "link_flair_text_color": "dark",
          "upvote_ratio": 0.74,
          "author_flair_background_color": null,
          "subreddit_type": "public",
          "ups": 13,
          "total_awards_received": 0,
          "media_embed": {},
          "author_flair_template_id": null,
          "is_original_content": false,
          "user_reports": [],
          "secure_media": null,
          "is_reddit_media_domain": false,
          "is_meta": false,
          "category": null,
          "secure_media_embed": {},
          "link_flair_text": null,
          "can_mod_post": false,
          "score": 13,
          "approved_by": null,
          "is_created_from_ads_ui": false,
          "author_premium": false,
          "thumbnail": "",
          "edited": 1626212827,
          "author_flair_css_class": null,
          "author_flair_richtext": [],
          "gildings": {},
          "content_categories": null,
          "is_self": true,
          "mod_note": null,
          "created": 1626225328,
          "link_flair_type": "text",
          "wls": 6,
          "removed_by_category": null,
          "banned_by": null,
          "author_flair_type": "text",
          "domain": "self.haskell",
          "allow_live_comments": false,
          "selftext_html": "&lt;!-- SC_OFF --&gt;&lt;div class=\"md\"&gt;&lt;p&gt;Essentially, a friend of mine was like &amp;quot;How do you even read a file in a purely functional language?&amp;quot;&lt;/p&gt;\n\n&lt;p&gt;So I sat down with him and wrote a program that is essentially the &lt;code&gt;cat&lt;/code&gt; tool without all the bloat like &lt;code&gt;--help&lt;/code&gt; and stuff: take filename in, read the file, print it out. And that program literally takes two lines of Haskell code. It came out so concise without me even trying that I just had to share it with you.&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;import System.Environment (getArgs)\nmain = getArgs &amp;gt;&amp;gt;= (readFile . head) &amp;gt;&amp;gt;= putStrLn\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;It&amp;#39;s actually just &lt;strong&gt;one&lt;/strong&gt; line of useful code if you exclude the import statement. Show me a language that can do it more elegantly! I&amp;#39;ll wait...&lt;/p&gt;\n\n&lt;p&gt;&lt;strong&gt;Update:&lt;/strong&gt; some people didn&amp;#39;t like the fact that my &amp;#39;cat&amp;#39; implementation doesn&amp;#39;t support file concatenation and offered their implementations. I&amp;#39;ve come up with two that are also good-looking.&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;import System.Environment (getArgs)\nimport Control.Monad\nmain = getArgs &amp;gt;&amp;gt;= traverse (readFile &amp;gt;=&amp;gt; putStr)\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;This one requires Control.Monad, but looks slick. However, it can be avoided using some lambda magic:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;import System.Environment (getArgs)\nmain = getArgs &amp;gt;&amp;gt;= traverse (\\file -&amp;gt; readFile file &amp;gt;&amp;gt;= putStr)\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;This works exactly the same, but your linter will urge you to use &lt;code&gt;&amp;gt;=&amp;gt;&lt;/code&gt; (you don&amp;#39;t have to obey).&lt;/p&gt;\n&lt;/div&gt;&lt;!-- SC_ON --&gt;",
          "likes": null,
          "suggested_sort": null,
          "banned_at_utc": null,
          "view_count": null,
          "archived": false,
          "no_follow": false,
          "is_crosspostable": false,
          "pinned": false,
          "over_18": false,
          "all_awardings": [],
          "awarders": [],
          "media_only": false,
          "can_gild": false,
          "spoiler": false,
          "locked": false,
          "author_flair_text": null,
          "treatment_tags": [],
          "visited": false,
          "removed_by": null,
          "num_reports": null,
          "distinguished": null,
          "subreddit_id": "t5_2qh36",
          "mod_reason_by": null,
          "removal_reason": null,
          "link_flair_background_color": "",
          "id": "ojk63k",
          "is_robot_indexable": true,
          "report_reasons": null,
          "author": "sharpvik",
          "discussion_type": null,
          "num_comments": 25,
          "send_replies": true,
          "whitelist_status": "all_ads",
          "contest_mode": false,
          "mod_reports": [],
          "author_patreon_flair": false,
          "author_flair_text_color": null,
          "permalink": "/r/haskell/comments/ojk63k/smallest_cat_utility_thats_ever_existed/",
          "parent_whitelist_status": "all_ads",
          "stickied": false,
          "url": "https://www.reddit.com/r/haskell/comments/ojk63k/smallest_cat_utility_thats_ever_existed/",
          "subreddit_subscribers": 64950,
          "created_utc": 1626196528,
          "num_crossposts": 0,
          "media": null,
          "is_video": false
        }
      }
    ],
    "before": null
  }
}
